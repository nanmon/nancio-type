{"version":3,"sources":["util/std.ts","util/text.ts","reducers/typing.ts","reducers/index.ts","reducers/init.ts","reducers/screen.ts","components/Caret.tsx","components/Char.tsx","components/Word.tsx","components/TypingTest.tsx","components/Typer.tsx","hooks/typing-test.ts","components/Stats.tsx","components/Screens.tsx","pages/quotes/Quotes.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["last","array","length","tuplify","firstItems","arrays","map","first","index","arr","getWords","text","split","filter","w","getChars","getExtra","typed","substr","mistype","state","char","includes","content","wordsTyped","lastWord","actualWord","endsWith","lastChar","flushStats","newDelta","time","wpm","temp","count","stats","errs","errors","delta","prevTime","ducers","init","_state","action","screen","prevCount","config","fontFamily","fontSize","lineHeight","width","colors","left","correct","wrong","extra","caret","typing","fns","arg","rest","reduce","acc","fn","compose","newState","typedWords","allWords","lastTyped","pop","doneTyping","reducer","r","type","Caret","position","focused","useTyper","React","useState","className","setClassName","useEffect","timeoutId","setTimeout","clearTimeout","style","top","transform","x","y","color","visibility","Char","code","useMemo","str","join","Word","current","_chars","extraStr","forEach","push","redline","c","space","context","document","createElement","getContext","font","measureText","getWidth","marginRight","borderBottomColor","TypingTest","dispatch","useContext","DispatchContext","inputRef","useRef","inputHasFocus","setInputFocus","capslock","setCapslock","caretPosition","pos","setPos","wordEl","querySelector","originRect","getBoundingClientRect","wrect","charsTyped","querySelectorAll","rect","right","bottom","useCaret","focus","_words","slice","capslockDetector","e","getModifierState","offset","line","Math","floor","ref","onKeyDown","key","Date","now","preventDefault","onKeyUp","height","padding","border","onFocus","onBlur","onClick","maxWidth","word","prev","next","typedWord","prevTyped","nextTyped","Stats","counts","incorrect","missing","extras","wtext","wtyped","chtext","chtyped","charCounts","s","v","title","Screens","StateContext","createContext","Typer","onType","useReducer","Provider","value","quotes","require","Quotes","randomQuote","quote","setQuote","useCallback","t","random","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.c40feb78.chunk.js","sourcesContent":["interface ArrayLike {\n  [index: number]: any; \n  length: number\n}\n\nexport const clamp = (min: number, max: number) => (val: number) => {\n  if (val < min) return min;\n  if (val > max) return max;\n  return val;\n}\n\nexport const compose = (...fns: Function[]) => (arg: any, ...rest: any[]) => {\n  return fns.reduce((acc, fn) => fn(acc, ...rest), arg);\n}\n\nexport const last = (array: ArrayLike) => {\n  return array[array.length - 1];\n}\n\nexport const fillBetween = (\n  fn: Function\n) => (array: any[]) => {\n  const befores = array.slice(0, array.length - 1);\n  const afters = array.slice(1);\n\n  const res = tuplify(befores, afters)\n    .map(([before, after], index) => [before, fn(before, after, index)])\n    .flat();\n  res.push(last(array));\n  return res;\n}\n\nexport const tuplify = (firstItems: any[], ...arrays: any[][]) => {\n  return firstItems.map((first, index) => {\n    return [\n      first, \n      ...arrays.map(arr => arr[index])\n    ];\n  });\n}\n\nexport const memoize = (fn: Function, stackSize = 15) => {\n  const memory: Record<string, any> = {};\n  const keyStack: string[] = [];\n  return (...args: any[]) => {\n    const key = JSON.stringify(args);\n    if (!memory[key]) \n      memory[key] = fn(...args);\n    \n    // key cache\n    const keyIndex = keyStack.indexOf(key);\n    if (keyIndex !== -1) keyStack.splice(keyIndex, 1);\n    else if (keyStack.length >= stackSize) {\n      const oldKey = keyStack.shift();\n      delete memory[oldKey!];\n    }\n    keyStack.push(key);\n\n    return memory[key];\n  }\n}\n\nexport const spread = (obj: {[k:string]: any} | any[], path: (string | number)[], value: any): object => {\n  const [key, ...otherKeys] = path;\n  if (obj instanceof Array) {\n    return [\n      ...obj.slice(0, Number(key)),\n      otherKeys.length === 0\n        ? value\n        : spread(obj[Number(key)], otherKeys, value),\n      ...obj.slice(Number(key))\n    ]\n  }\n  return {\n    ...obj,\n    [key]: otherKeys.length === 0\n      ? value\n      : spread(obj[key + ''], otherKeys, value)\n  }\n}\n\n\nexport function avg(array: number[]) {\n  return array.reduce((s, v) => s + v, 0) / array.length;\n}","import { tuplify } from './std'\n\nexport const getWords = (text = '') => {\n  return text.split(' ').filter(w => w);\n}\n\nexport const getChars = (text = '') => {\n  return text.split('');\n}\n\nexport const getExtra = (text: string, typed = '') => {\n  if (typed.length > text.length)\n    return typed.substr(text.length);\n  return '';\n}\n\nexport const withExtra = (text: string, typed: string) => {\n  const wtext = getWords(text);\n  const wtyped = getWords(typed);\n  return tuplify(wtext, wtyped).map(([text, typed]) => {\n    return text + getExtra(text, typed);\n  }).join(' ');\n}\n\nexport const getWidth = (\n  text: string, \n  {fontFamily, fontSize}: {fontFamily: string, fontSize: number}\n) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context!.font = `${fontSize}px ${fontFamily}`;\n  return context!.measureText(text).width;\n}","import { compose, last } from '../util/std';\nimport { getWords } from '../util/text';\n\nconst typing: (\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) => Typer.State =  compose(\n  setTyped,\n  setCount,\n  setErrors,\n  setTemp,\n  setDone\n);\n\nexport default typing;\n\nfunction setTyped(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  let { typed } = state;\n  // dont add spaces together\n  if (char === ' ' && typed.endsWith(' ')) return state;\n  if (char === 'Backspace')\n    typed = typed.substr(0, typed.length - 1);\n  else typed = typed + char;\n  return { ...state, typed };\n}\n\nfunction setCount(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  if (['', 'Backspace'].includes(char)) \n    return state;\n  return {\n    ...state,\n    stats: { ...state.stats, count: state.stats.count + 1 }\n  };\n}\n\nfunction setErrors(\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) {\n  if (mistype(state, action))\n    return {\n      ...state,\n      stats: { ...state.stats, errors: state.stats.errors + 1 }\n    };\n  return state;\n}\n\nfunction setTemp(\n  state: Typer.State, \n  { time, char }: Typer.Actions.Typing\n) {\n  const { temp } = state;\n  if (temp.prevTime === 0) {\n    return {\n      ...state,\n      temp: {\n        delta: 0,\n        prevTime: time,\n        count: ['', 'Backspace'].includes(char) ? 0 : 1,\n        errors: mistype(state, { char }) ? 1 : 0\n      }\n    }\n  }\n  let delta = temp.delta + (time - temp.prevTime);\n  if (delta < 1000) {\n    return {\n      ...state,\n      temp: {\n        delta,\n        prevTime: time,\n        count: char === 'Backspace' ? temp.count : temp.count + 1,\n        errors: mistype(state, { char }) ? temp.errors + 1 : temp.errors\n      }\n    }\n  }\n  let newState = {...state};\n  while (delta > 1000) {\n    delta -= 1000;\n    newState = flushStats(newState, { time, char }, delta);\n    char = '';\n  }\n  return newState;\n}\n\nfunction setDone(state: Typer.State) {\n  if (doneTyping(state))\n    return {\n      ...state,\n      screen: 'stats'\n    }\n  return state;\n}\n\nfunction mistype(\n  state: Typer.State, \n  { char }: Pick<Typer.Actions.Typing, 'char'>\n) {\n  if (['', 'Backspace'].includes(char)) return false;\n\n  const { typed, content } = state;\n  const wordsTyped = getWords(typed);\n  const lastWord = last(wordsTyped);\n  const actualWord = getWords(content.text)[wordsTyped.length - 1];\n\n  // it'd be like that sometimes\n  if (!actualWord) return false;\n\n  if (typed.endsWith(' '))\n    return actualWord.length > lastWord.length;\n\n  const lastChar = lastWord[lastWord.length - 1];\n  const actualChar = actualWord[lastWord.length - 1];\n  return actualChar !== lastChar;\n}\n\nfunction flushStats(\n  state: Typer.State, \n  { time, char }: Pick<Typer.Actions.Typing, 'time' | 'char'>, \n  newDelta: number\n) {\n  const pm = 1 / 60 * 5;\n  const wpm = state.temp.count / pm;\n  return {\n    ...state,\n    stats: {\n      ...state.stats,\n      wpm: [...state.stats.wpm, wpm],\n      errs: [...state.stats.errs, state.temp.errors]\n    },\n    temp: {\n      delta: newDelta,\n      prevTime: time,\n      count: ['', 'Backspace'].includes(char) ? 0 : 1,\n      errors: mistype(state, { char }) ? 1 : 0\n    }\n  };\n}\n\nfunction doneTyping({ typed, content }: Typer.State) {\n  const typedWords = getWords(typed);\n  const allWords = getWords(content.text);\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}","import init from './init';\nimport typing from './typing';\nimport screen from './screen';\n\nconst ducers = {\n  init,\n  typing,\n  screen\n};\n\nexport default function reducer(\n  state: Typer.State | null, \n  action: Typer.Actions.Any) \n{\n  const r = ducers[action.type] as Reducer;\n  if (!r) return state;\n  return r(state, action);\n}\n\ntype Reducer = (state: Typer.State | null, action: Typer.Actions.Any) => Typer.State;","export default function init(\n  _state: Typer.State | null, \n  action: Typer.Actions.Init\n): Typer.State {\n  return {\n    content: action.content,\n    typed: '',\n    screen: 'typing',\n    stats: {\n      count: 0, \n      prevCount: 0, \n      wpm: [], \n      errors: 0,\n      errs: []\n    },\n    temp: {\n      prevTime: 0,\n      delta: 0,\n      errors: 0,\n      count: 0\n    },\n    config: {\n      fontFamily: 'monospace',\n      fontSize: 24,\n      lineHeight: 30,\n      width: 800, \n      colors: {\n        left: 'gray',\n        correct: 'white',\n        wrong: 'red',\n        extra: 'darkred',\n        caret: 'cyan'\n      }\n    }\n  }\n}","export default function screen(\n  state: Typer.State, \n  action: Typer.Actions.Screen\n): Typer.State {\n  return {\n    ...state,\n    screen: action.screen\n  }\n}","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  position: Typer.CaretPosition | null;\n  focused: boolean;\n}\n\nfunction Caret({ position, focused }: Props) {\n  const { config, typed } = useTyper();\n  const [className, setClassName] = React.useState('caret');\n\n  React.useEffect(() => {\n    setClassName('caret');\n    const timeoutId = setTimeout(() => {\n      setClassName('caret animated');\n    }, 500);\n    return () => clearTimeout(timeoutId);\n  }, [typed]);\n\n  if (!position) return null;\n\n  return (\n    <span \n      className={className}\n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        transform: `translate(${position.x - 8}px, ${position.y - 2}px)`,\n        color: config.colors.caret,\n        visibility: focused ? 'visible' : 'hidden'\n      }}\n    >|\n    </span>\n  );\n} \n\nexport default Caret;","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  text?: string;\n  typed?: string;\n}\n\nfunction Char({ text, typed }: Props) {\n  const { config } = useTyper();\n  const code = React.useMemo(() => {\n    if (!typed) return 'left';\n    if (!text) return 'extra';\n    if (typed === text) return 'correct';\n    return 'wrong';\n  }, [text, typed]);\n  const color = config.colors[code]\n  const str = text || typed;\n  const className = ['Char', code].join(' ')\n  return (\n    <span className={className} style={{color}}>{str}</span>\n  );\n}\n\nexport default Char;","import Char from \"./Char\";\nimport { useTyper } from \"./Typer\";\nimport { tuplify } from \"../util/std\";\nimport { getChars, getExtra, getWidth } from \"../util/text\";\nimport '../styles/Word.css';\n\ninterface Props {\n  text: string;\n  typed: string;\n  current: boolean;\n}\n\nfunction Word({ text, typed, current }: Props) {\n  const { config } = useTyper();\n  const _chars = tuplify(\n    getChars(text),\n    getChars(typed),\n  );\n  const extraStr = getExtra(text, typed);\n  getChars(extraStr).forEach(char => {\n    _chars.push([null, char]);\n  });\n  const redline = !current && typed && text !== typed;\n  const className = [\n    \"Word\", \n    redline && 'redline',\n    current && 'current'\n  ].filter(c => c).join(' ');\n  const space = getWidth(' ', config);\n  return (\n    <div \n      className={className} \n      style={{\n        marginRight: space, \n        borderBottomColor: redline ? config.colors.wrong : 'transparent'\n      }}\n    >\n      {_chars.map(([text, typed], index) => \n        <Char \n          key={index}\n          text={text}\n          typed={typed}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default Word;","import React from 'react';\nimport { tuplify } from '../util/std';\nimport { getWords } from '../util/text'\nimport { useTyper, useTyperDispatch } from './Typer'\nimport Caret from './Caret';\nimport Word from './Word';\nimport '../styles/TypingTest.css';\nimport { useCaret } from '../hooks/typing-test';\n\nfunction TypingTest() {\n  const { content, typed, config } = useTyper();\n  const dispatch = useTyperDispatch();\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [inputHasFocus, setInputFocus] = React.useState(false);\n  const [capslock, setCapslock] = React.useState(false);\n  const caretPosition = useCaret(typed, config);\n\n  React.useEffect(() => {\n    inputRef.current?.focus();\n  }, [content.text]);\n\n  const typedWords = getWords(typed)\n  const _words = tuplify(\n    getWords(content.text),\n    typedWords,\n    [null, ...typedWords],\n    typedWords.slice(1)\n  )\n\n  function onKeyPress(e: React.KeyboardEvent<HTMLInputElement>) {\n    capslockDetector(e);\n    const char = e.key;\n    if (char.length === 1 || char === 'Backspace') {\n      dispatch({ type: 'typing', char, time: Date.now() });\n      e.preventDefault();\n      return;\n    }\n  }\n\n  function capslockDetector(e: React.KeyboardEvent<HTMLInputElement>) {\n    setCapslock(e.getModifierState('CapsLock'));\n  }\n\n  function isCurrent(word: string, prev: string, next: string) {\n    if (!typed && !prev) return true;\n    if (typed.endsWith(' ')) return prev != null && word == null;\n    return word != null && next == null;\n  }\n\n  const offset = React.useMemo(() => {\n    if (!caretPosition) return 0;\n    const line = Math.floor(caretPosition.y / config.lineHeight);\n    if (line < 1) return 0\n    return (line - 1) * config.lineHeight;\n  }, [caretPosition, config]);\n\n  return (\n    <div className=\"TypingTest\" style={{\n      fontFamily: config.fontFamily,\n      fontSize: config.fontSize + 'px',\n      lineHeight: (config.lineHeight - 2) + 'px', // 2px border bottom\n    }}>\n      <input \n        ref={inputRef}\n        onKeyDown={onKeyPress}\n        onKeyUp={capslockDetector}\n        style={{height: 0, padding: 0, border: 0, position: \"absolute\"}}\n        onFocus={() => setInputFocus(true)}\n        onBlur={() => setInputFocus(false)}\n      />\n      <p style={{visibility: capslock ? \"visible\" : \"hidden\"}}>\n        CAPSLOCK IS ACTIVE\n      </p>\n      <div className=\"threeLines\" style={{height: config.lineHeight * 3 + 'px'}}>\n        <div \n          className=\"words\" \n          onClick={() => inputRef.current?.focus()}\n          style={{ maxWidth: config.width, transform: `translateY(${-offset}px)`}}\n        >\n          {_words.map(([text, typedWord, prevTyped, nextTyped], index) => \n            <Word\n              key={index}\n              text={text} \n              typed={typedWord}\n              current={isCurrent(typedWord, prevTyped, nextTyped)} \n            />\n          )}\n          <Caret position={caretPosition} focused={inputHasFocus} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default TypingTest;\n","import React from 'react';\nimport reducer from '../reducers';\nimport Screens from './Screens';\n\nexport * from '../util/handlers';\n\nconst StateContext = \n  React.createContext<Typer.State>(init({ text: '' })!);\nconst DispatchContext = \n  React.createContext<React.Dispatch<Typer.Actions.Any> | null>(null);\n\ninterface Props {\n  content: Typer.Content;\n  onType?(state: Typer.State): void;\n}\n\nexport function Typer({ content, onType }: Props) {\n  const [state, dispatch] = React.useReducer(reducer, null, () => init(content));\n\n  React.useEffect(() => {\n    dispatch({type: 'init', content });\n  }, [content]);\n\n  const prevTyped = React.useRef<string | null>(null);\n  React.useEffect(() => {\n    if (!onType || prevTyped.current === state!.typed) return;\n    prevTyped.current = state!.typed;\n    onType(state!);\n  }, [state, onType]);\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state!}>\n        <Screens/>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n\nexport function useTyper() {\n  return React.useContext(StateContext);\n}\n\nexport function useTyperDispatch() {\n  return React.useContext(DispatchContext)!;\n}\n\nfunction init(content: Typer.Content) {\n  return reducer(null, { type: 'init', content });\n}","import React from 'react';\nimport { last } from '../util/std';\n\nexport function useCaret(typed: string, config: Typer.Config) {\n  const [pos, setPos] = React.useState<Typer.CaretPosition | null>(null);\n\n  React.useEffect(() => {\n    const wordEl = document.querySelector('.Word.current');\n    if (!wordEl) return;\n    const wordsEl = document.querySelector('.words')!;\n    const originRect = wordsEl.getBoundingClientRect();\n    const wrect = wordEl.getBoundingClientRect();\n    let charsTyped = wordEl.querySelectorAll('.Char:not(.left)');\n    if (charsTyped.length === 0) {\n      setPos({\n        x: wrect.left - originRect.left,\n        y: wrect.bottom - originRect.top - config.lineHeight\n      });\n      return;\n    }\n    const char = last(charsTyped);\n    const rect = char.getBoundingClientRect();\n    setPos({\n      x: rect.right - originRect.left,\n      y: wrect.bottom - originRect.top - config.lineHeight\n    });\n  }, [typed, config]);\n\n  return pos\n}","import { tuplify, avg } from '../util/std';\nimport { getChars, getWords, getExtra } from '../util/text';\nimport { useTyper } from './Typer';\n\nfunction Stats() {\n  const { stats, content, typed } = useTyper();\n  const acc = (1 - stats.errors / content.text.length) * 100\n  const counts = charCounts(content.text, typed);\n  return (\n    <>\n      <p>Avg: {avg(stats.wpm)} wpm</p>\n      <p>Time: {stats.wpm.length}s </p>\n      <p>Acc: {acc}%</p>\n      <p title=\"correct/incorrect/extra/missing\">Chars: {counts.correct}/{counts.incorrect}/{counts.extra}/{counts.missing}</p>\n    </>\n  )\n}\n\nexport default Stats;\n\nfunction charCounts(text: string, typed: string) {\n  let correct = 0, incorrect = 0, missing = 0, extras = 0\n  tuplify(\n    getWords(text),\n    getWords(typed)\n  ).forEach(([wtext, wtyped]) => {\n    tuplify(\n      getChars(wtext),\n      getChars(wtyped)\n    ).forEach(([chtext, chtyped]) => {\n      if (!chtyped) missing++;\n      else if (chtext === chtyped) correct++;\n      else incorrect++;\n    });\n    getChars(getExtra(wtext, wtyped)).forEach(() => extras++);\n  })\n  return {correct, incorrect, missing, extra: extras }\n}","import TypingTest from './TypingTest';\nimport Stats from './Stats';\nimport { useTyper } from './Typer';\n\nfunction Screens() {\n\n  const { screen } = useTyper();\n\n  return screen === 'stats' \n        ? <Stats />\n        : <TypingTest />;\n}\n\nexport default Screens;","import React from 'react';\nimport { Typer } from '../../components/Typer';\nconst { quotes } = require('./quotes.json')\n\nfunction Quotes() {\n  const [quote, setQuote] = React.useState(randomQuote);\n\n  const onType = React.useCallback(t => {\n    // console.log(t);\n  }, [])\n\n  return (\n    <>\n      <Typer content={quote} onType={onType}/>\n      <button onClick={() => setQuote(randomQuote())}>Next</button>\n    </>\n  );\n}\n\nexport default Quotes;\n\nfunction randomQuote() {\n  const index = Math.floor(Math.random() * quotes.length);\n  return quotes[index]\n}","import './App.css';\nimport Quotes from './pages/quotes/Quotes';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Quotes/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
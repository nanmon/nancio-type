{"version":3,"sources":["util/text.ts","pages/quotes/Quotes.tsx","util/handlers.ts","reducers/merge.ts","reducers/index.ts","reducers/init.ts","reducers/typing.ts","reducers/screen.ts","components/Caret.tsx","components/Char.tsx","components/Word.tsx","components/Line.tsx","components/TypingTest.tsx","components/Stats.tsx","components/Screens.tsx","components/Typer.tsx"],"names":["IGNORED_CHARACTERS","IGNORED_MODIFIERS","getWords","text","split","filter","w","getChars","getExtra","typed","length","substr","getWidth","fontFamily","fontSize","context","document","createElement","getContext","font","measureText","width","getLines","typedWords","words","zip","currentLength","currentLine","lines","forEach","word","wlength","push","trim","getCaretPosition","wcount","lineIndex","findIndex","line","lwords","charIndex","slice","join","endsWith","rand","count","Math","floor","random","Quotes","React","useState","quotes","setQuotes","index","setIndex","useEffect","fetch","process","then","r","json","onType","useCallback","t","content","onClick","lastWpm","state","milis","timeline","endTime","last","timestamp","timeSlice","st","rawWpm","isDoneTyping","allWords","pop","netWpm","errors","typedWord","typedChar","unfixedErrors","typedMilis","i","includes","char","typedCount","mistypedLast","wordsTyped","lastWord","actualWord","lastChar","from","to","overtime","start","end","merge","ducers","init","action","reset","screen","temp","prevTime","delta","config","lineHeight","colors","left","correct","wrong","extra","caret","typing","newState","setTyped","setDone","time","addToTimeline","Object","entries","some","key","val","reducer","type","Caret","position","focused","useTyper","className","setClassName","timeoutId","setTimeout","clearTimeout","x","y","charWidth","clampedY","style","top","transform","color","visibility","Char","memo","code","useMemo","str","Word","current","_chars","redline","c","space","marginRight","borderBottomColor","map","Line","undefined","prev","next","prevTyped","nextTyped","TypingTest","onKeyPress","dispatch","useTyperDispatch","inputRef","useRef","inputHasFocus","setInputFocus","capslock","setCapslock","focus","capslockDetector","e","getModifierState","drawingLines","threeLinesHeight","ref","onKeyDown","mod","Date","now","preventDefault","onKeyUp","height","padding","border","onFocus","onBlur","Stats","counts","incorrect","missing","extras","wtext","wtyped","chtext","chtyped","charCounts","startTime","duration","chartData","data","Array","round","_","second","wpm","wpmPoint","raw","slicePoint","errorPoint","typedPoint","acc","total","reduce","sum","d","ComposedChart","yAxisId","dataKey","stroke","fill","Scatter","CartesianGrid","strokeDasharray","XAxis","tickCount","domain","allowDecimals","YAxis","orientation","Tooltip","errs","item","Number","Screens","StateContext","createContext","DispatchContext","Typer","restartOnContentChange","useReducer","Provider","value","useContext"],"mappings":"8ZAEaA,EAAqB,CAAC,GAAI,aAC1BC,EAAoB,CAAC,MAAO,WAAY,UAAW,KAAM,OAAQ,MAEjEC,EAAW,WAAgB,IAAfC,EAAc,uDAAP,GAC9B,OAAOA,EAAKC,MAAM,KAAKC,QAAO,SAAAC,GAAC,OAAIA,MAGxBC,EAAW,WAAgB,IAAfJ,EAAc,uDAAP,GAC9B,OAAOA,EAAKC,MAAM,KAGPI,EAAW,SAACL,GAA8B,IAAhBM,EAAe,uDAAP,GAC7C,OAAIA,EAAMC,OAASP,EAAKO,OACfD,EAAME,OAAOR,EAAKO,QACpB,IAWIE,EAAW,SACtBT,EADsB,GAGlB,IADHU,EACE,EADFA,WAAYC,EACV,EADUA,SAGPC,EADSC,SAASC,cAAc,UACfC,WAAW,MAElC,OADAH,EAASI,KAAT,UAAmBL,EAAnB,cAAiCD,GAC1BE,EAASK,YAAYjB,GAAMkB,OAGvBC,EAAW,SACtBnB,EACAM,EAFsB,GAIlB,IADFY,EACC,EADDA,MAEIE,EAAarB,EAASO,GACtBe,EAAQC,IACZvB,EAASC,GACToB,GAEEG,EAAgB,EAChBC,EAAgC,CAAC,GAAI,IACnCC,EAA4B,GAmBlC,OAlBAJ,EAAMK,SAAQ,YAAoB,IAAD,mBAAjBC,EAAiB,KAAXrB,EAAW,KAC/B,GAAKqB,EAAL,CACA,IAAIC,EAAUD,EAAKpB,OACfD,GAASA,EAAMC,OAASoB,EAAKpB,SAAQqB,EAAUtB,EAAMC,QACrDgB,EAAgB,EAAIK,EAAUV,GAChCK,EAAgBK,EAChBH,EAAMI,KAAK,CACTL,EAAY,GAAGM,OACfN,EAAY,GAAGM,SAEjBN,EAAc,CAACG,EAAMrB,GAAS,MAE9BiB,GAAiB,EAAIK,EACrBJ,EAAY,IAAM,IAAMG,EACpBrB,IAAOkB,EAAY,IAAM,IAAMlB,QAGnCkB,EAAYjB,OAAS,GAAGkB,EAAMI,KAAKL,GAChCC,GAGIM,EAAmB,SAACN,EAAiBnB,GAChD,IAAMe,EAAQtB,EAASO,GACnB0B,EAAS,EACPC,EAAYR,EAAMS,WAAU,SAAAC,GAChC,IAAMC,EAASrC,EAASoC,GACxB,OAAIH,EAASI,EAAO7B,QAAUc,EAAMd,SACpCyB,GAAUI,EAAO7B,QACV,MAGL8B,EADchB,EAAMiB,MAAMN,GACJO,KAAK,KAAKhC,OAEpC,OADID,EAAMkC,SAAS,MAAMH,IAClB,CAACA,EAAWJ,K,mFChDrB,SAASQ,EAAKC,GACZ,OAAOC,KAAKC,MAAMD,KAAKE,SAAWH,GAJrBI,UA3Bf,WAAmB,IAAD,EACYC,IAAMC,SAA0B,IAD5C,mBACTC,EADS,KACDC,EADC,OAEUH,IAAMC,UAAU,GAF1B,mBAETG,EAFS,KAEFC,EAFE,KAIhBL,IAAMM,WAAU,WACdC,MAPeC,yFAQZC,MAAK,SAAAC,GAAC,OAAIA,EAAEC,UACZF,MAAK,YAAiB,IAAdP,EAAa,EAAbA,OACPC,EAAUD,GACVG,EAASX,EAAKQ,EAAO1C,cAExB,IAEH,IAAMoD,EAASZ,IAAMa,aAAY,SAAAC,MAE9B,IAEH,OAAe,IAAXV,EAAqB,6CAGvB,qCACE,cAAC,IAAD,CAAOW,QAASb,EAAOE,GAAQQ,OAAQA,IACvC,wBAAQI,QAAS,kBAAMX,EAASX,EAAKQ,EAAO1C,UAA5C,uB,ocCaC,SAASyD,EAAQC,GAAmC,IAAfC,EAAc,uDAAN,IAClD,GAA8B,IAA1BD,EAAME,SAAS5D,OAAc,OAAO,EACxC,IAAM6D,EAAUC,IAAKJ,EAAME,UAAWG,UAClChC,EAAQiC,EACVN,EACAG,EAAUF,EACVE,EAAU,KACV,GAEF,GAAqB,IAAjB9B,EAAM/B,OAAc,OAAO,EAC/B,IAAMD,EAAQ+D,IAAK/B,GAAQhC,MACrBkE,EAAK,CAAElE,QAAOwD,QAASG,EAAMH,QAASK,SAAU7B,GACtD,OAAOmC,EAAOD,GAGT,SAASE,EAAT,GAAwD,IAAhCpE,EAA+B,EAA/BA,MAAOwD,EAAwB,EAAxBA,QAC9B1C,EAAarB,YAASO,GACtBqE,EAAW5E,YAAS+D,EAAQ9D,MAClC,QAAIoB,EAAWb,OAASoE,EAASpE,YAC7BD,EAAMkC,SAAS,MACDpB,EAAWwD,QACZD,EAASC,OAIrB,SAASC,EAAOZ,GACrB,OAAOQ,EAAOR,GAkBT,SAAuBA,GAC5B,IAAIa,EAAS,EACP1D,EAAarB,YAASkE,EAAM3D,OAiBlC,OAhBAgB,IACEF,EACArB,YAASkE,EAAMH,QAAQ9D,OACvB0B,SAAQ,WAAoByB,GAAW,IAAD,mBAA5B4B,EAA4B,KAAjBpD,EAAiB,KACjCA,GAASoD,IACV5B,EAAQ/B,EAAWb,OAAQ,GAAKoB,EAAKpB,OAASwE,EAAWxE,QAC3DuE,IAEFxD,IACElB,YAAS2E,GACT3E,YAASuB,IACTD,SAAQ,YAAwB,IAAD,mBAArBsD,EAAqB,YAClBA,GACbF,WAGGA,EArCgBG,CAAchB,GAASiB,EAAWjB,GAAS,IAAO,GAGpE,SAASQ,EAAOR,GACrB,OAGK,SAAoBA,GACzB,OAAOA,EAAME,SACVjE,QAAO,SAAAiF,GAAC,OAAKtF,IAAmBuF,SAASD,EAAEE,SAC3C9E,OANI+E,CAAWrB,GAASiB,EAAWjB,GAAS,IAAO,GAAK,EAStD,SAASiB,EAAWjB,GACzB,OAA8B,IAA1BA,EAAME,SAAS5D,OAAqB,EACjC8D,IAAKJ,EAAME,UAAWG,UAAYL,EAAME,SAAS,GAAGG,UAuDtD,SAASiB,EACdtB,GACC,IACO3D,EAAmB2D,EAAnB3D,MAAOwD,EAAYG,EAAZH,QACf,IAAKxD,EAAO,OAAO,EACnB,IAAM+E,EAAOhB,IAAK/D,GAClB,GAAIT,IAAmBuF,SAASC,GAAO,OAAO,EAE9C,IAAMG,EAAazF,YAASO,GACtBmF,EAAWpB,IAAKmB,GAChBE,EAAa3F,YAAS+D,EAAQ9D,MAAMwF,EAAWjF,OAAS,GAG9D,IAAKmF,EAAY,OAAO,EAExB,GAAIpF,EAAMkC,SAAS,KAGjB,OADgBkD,EAAWnF,OAASkF,EAASlF,OAC5B,EAGnB,IAAMoF,EAAWF,EAASA,EAASlF,OAAS,GAE5C,OADmBmF,EAAWD,EAASlF,OAAS,KAC1BoF,EAGjB,SAASpB,EACdN,EACA2B,EACAC,GAEC,IADDC,EACA,wDACIC,EAAQ9B,EAAME,SAASjC,WAAU,SAAAiD,GAAC,OAAIA,EAAEb,WAAasB,KACrDI,EAAM/B,EAAME,SAASjC,WAAU,SAAAiD,GAAC,OAAIA,EAAEb,WAAauB,KAOvD,OANe,IAAXE,IAAcA,EAAQ,IACb,IAATC,IAAYA,EAAM/B,EAAME,SAAS5D,OAAS,GAC1CuF,IACEC,EAAQ,GAAGA,IACXC,EAAM/B,EAAME,SAAS5D,OAAS,GAAGyF,KAEhC/B,EAAME,SAAS7B,MAAMyD,EAAOC,GCtKtBC,ICLTC,EAAS,CACbC,KCNa,SACblC,EACAmC,GAEA,OAAKA,EAAOC,MAOL,CACLvC,QAASsC,EAAOtC,QAChBxD,MAAO,GACPgG,OAAQ,SACRC,KAAM,CACJC,SAAU,EACVC,MAAO,EACP3B,OAAQ,EACRpC,MAAO,GAETyB,SAAU,GACVuC,OAAQ,CACNhG,WAAY,YACZC,SAAU,GACVgG,WAAY,GACZzF,MAAO,GACP0F,OAAQ,CACNC,KAAM,OACNC,QAAS,QACTC,MAAO,MACPC,MAAO,UACPC,MAAO,UA3BJ,2BACFhD,GADL,IAEEH,QAASsC,EAAOtC,QAChBK,SAAU,MDDd+C,OEJa,SACbjD,EACAmC,GAEA,IAAIe,EAON,SACElD,EADF,GAGG,IADCoB,EACF,EADEA,KAEI/E,EAAU2D,EAAV3D,MAEN,GAAa,MAAT+E,GAAgB/E,EAAMkC,SAAS,KAAM,OAAOyB,EACnC,cAAToB,EACF/E,EAAQA,EAAME,OAAO,EAAGF,EAAMC,OAAS,GACpCD,GAAgB+E,EACrB,OAAO,2BAAKpB,GAAZ,IAAmB3D,UAjBJ8G,CAASnD,EAAOmC,GAE/B,OAkCF,SAAiBnC,GACf,OAAIS,EAAaT,GACR,2BACFA,GADL,IAEEqC,OAAQ,UAELrC,EAxCAoD,CADPF,EAmBF,SACElD,EADF,GAGG,IADCoB,EACF,EADEA,KAAMiC,EACR,EADQA,KAER,IAAKrD,EAAM3D,OACLT,IAAmBuF,SAASC,GAAO,OAAOpB,EAEhD,OAAO,2BACFA,GADL,IAEEE,SAAS,GAAD,mBACHF,EAAME,UADH,CAEN,CAAEG,UAAWgD,EAAMjC,OAAM/E,MAAO2D,EAAM3D,WA9B/BiH,CAAcJ,EAAUf,KFAnCE,OGRa,SACbrC,EACAmC,GAEA,OAAO,2BACFnC,GADL,IAEEqC,OAAQF,EAAOE,UHGjBL,MDTF,SAAehC,EAAoBmC,GAGjC,OAFWoB,OAAOC,QAAQrB,EAAOnC,OAC9ByD,MAAK,mCAAEC,EAAF,KAAOC,EAAP,YAAgB3D,EAAM0D,KAASC,KAEhC,2BACF3D,GACAmC,EAAOnC,OAHMA,ICSL,SAAS4D,EACtB5D,EACAmC,GAEA,IAAM3C,EAAIyC,EAAOE,EAAO0B,MACxB,OAAKrE,EACEA,EAAEQ,EAAOmC,GADDnC,E,WIwBF8D,MAhCf,YAA8C,IAA7BC,EAA4B,EAA5BA,SAAUC,EAAkB,EAAlBA,QAAkB,EACjBC,IAAlBxB,EADmC,EACnCA,OAAQpG,EAD2B,EAC3BA,MAD2B,EAETyC,IAAMC,SAAS,SAFN,mBAEpCmF,EAFoC,KAEzBC,EAFyB,KAY3C,GARArF,IAAMM,WAAU,WACd+E,EAAa,SACb,IAAMC,EAAYC,YAAW,WAC3BF,EAAa,oBACZ,KACH,OAAO,kBAAMG,aAAaF,MACzB,CAAC/H,KAEC0H,EAAU,OAAO,KAZqB,kBAa5BA,EAb4B,GAapCQ,EAboC,KAajCC,EAbiC,KAcrCC,EAAYjI,YAAS,IAAKiG,GAC1BiC,EAAWF,EAAI,EAAI,EACzB,OACE,sBACEN,UAAWA,EACXS,MAAO,CACLZ,SAAU,WACVa,IAAK,EACLhC,KAAM,EACNiC,UAAU,aAAD,OAAeN,EAAIE,EAAY,EAA/B,eAAuCC,EAAWjC,EAAOC,WAAa,EAAtE,OACToC,MAAOrC,EAAOE,OAAOK,MACrB+B,WAAYf,EAAU,UAAY,UARtC,gBCFWgB,G,MAhBFlG,IAAMmG,MAAK,YAAuC,IAAvBlJ,EAAsB,EAAtBA,KAAMM,EAAgB,EAAhBA,MACpCoG,EAAWwB,IAAXxB,OACFyC,EAAOpG,IAAMqG,SAAQ,WACzB,OAAK9I,EACAN,EACDM,IAAUN,EAAa,UACpB,QAFW,QADC,SAIlB,CAACA,EAAMM,IACJyI,EAAQrC,EAAOE,OAAOuC,GACtBE,EAAMrJ,GAAQM,EACd6H,EAAY,CAAC,OAAQgB,GAAM5G,KAAK,KACtC,OACE,sBAAM4F,UAAWA,EAAWS,MAAO,CAACG,SAApC,SAA6CM,QCyBlCC,G,MAhCFvG,IAAMmG,MAAK,YAAgD,IAAhClJ,EAA+B,EAA/BA,KAAMM,EAAyB,EAAzBA,MAAOiJ,EAAkB,EAAlBA,QAC3C7C,EAAWwB,IAAXxB,OACF8C,EAASlI,IACblB,YAASJ,GACTI,YAASE,IAELmJ,GAAWF,GAAWjJ,GAASN,IAASM,EACxC6H,EAAY,CAChB,OACAsB,GAAW,UACXF,GAAW,WACXrJ,QAAO,SAAAwJ,GAAC,OAAIA,KAAGnH,KAAK,KAChBoH,EAAQlJ,YAAS,IAAKiG,GAC5B,OACE,qBACEyB,UAAWA,EACXS,MAAO,CACLgB,YAAaD,EACbE,kBAAmBJ,EAAU/C,EAAOE,OAAOG,MAAQ,eAJvD,SAOGyC,EAAOM,KAAI,WAAgB3G,GAAhB,uBAAEnD,EAAF,KAAQM,EAAR,YACV,cAAC,EAAD,CAEEN,KAAMA,EACNM,MAAOA,GAFF6C,YCIA4G,G,MA7BFhH,IAAMmG,MAAK,YAAuC,IAAvBlJ,EAAsB,EAAtBA,KAAMM,EAAgB,EAAhBA,MACtCc,EAAarB,YAASO,GACtBe,EAAQC,IACZvB,YAASC,GACToB,EAFe,MAGd4I,GAHc,mBAGA5I,IACfA,EAAWkB,MAAM,IASnB,OACE,qBAAK6F,UAAU,OAAf,SACG9G,EAAMyI,KAAI,WAA0C3G,GAA1C,IARIxB,EAAesI,EAAeC,EAQlC,mBAAElK,EAAF,KAAQ+E,EAAR,KAAmBoF,EAAnB,KAA8BC,EAA9B,YACTpK,GAAQ,cAAC,EAAD,CAENA,KAAMA,EACNM,MAAOyE,EACPwE,SAbW5H,EAaQoD,EAbOkF,EAaIE,EAbWD,EAaAE,GAZ1C9J,IAAU2J,IACX3J,EAAMkC,SAAS,KAAqB,MAARyH,GAAwB,MAARtI,EACjC,MAARA,GAAwB,MAARuI,KAOZ/G,YC2EAkH,MA3Ff,YAA4C,IAAtBC,EAAqB,EAArBA,WAAqB,EACNpC,IAA3BpE,EADiC,EACjCA,QAASxD,EADwB,EACxBA,MAAOoG,EADiB,EACjBA,OAClB6D,EAAWC,IAEXC,EAAW1H,IAAM2H,OAAyB,MAJP,EAKF3H,IAAMC,UAAS,GALb,mBAKlC2H,EALkC,KAKnBC,EALmB,OAMT7H,IAAMC,UAAS,GANN,mBAMlC6H,EANkC,KAMxBC,EANwB,KAQzC/H,IAAMM,WAAU,WAAO,IAAD,EACpB,UAAAoH,EAASlB,eAAT,SAAkBwB,UACjB,CAACjH,EAAQ9D,OAEZ,IAAMyB,EAAQsB,IAAMqG,SAAQ,WAC3B,OAAOjI,YAAS2C,EAAQ9D,KAAMM,EAAOoG,KACnC,CAACpG,EAAOwD,EAAS4C,IAEdO,EAAQlE,IAAMqG,SAAQ,WAC1B,OAAOrH,YAAiBN,EAAMqI,KAAI,0CAAaxJ,KAC9C,CAACmB,EAAOnB,IAsBX,SAAS0K,EAAiBC,GACxBH,EAAYG,EAAEC,iBAAiB,aAGjC,IAAMC,EAAepI,IAAMqG,SAAQ,WACjC,OAAInC,EAAM,GAAK,EAAUxF,EAAMa,MAAM,EAAG,GACjCb,EAAMa,MAAM2E,EAAM,GAAK,EAAGA,EAAM,GAAK,KAC3C,CAACxF,EAAOwF,IAELmE,EAAuC,EAApB1E,EAAOC,WAAiB,GAEjD,OACE,sBAAKwB,UAAU,aAAaS,MAAO,CACjClI,WAAYgG,EAAOhG,WACnBC,SAAU+F,EAAO/F,SAAW,KAC5BgG,WAAaD,EAAOC,WAAa,EAAK,MAHxC,UAKE,uBACE0E,IAAKZ,EACLa,UAvCN,SAAiBL,GAEf,GADAD,EAAiBC,IACbX,EAAWW,EAAG,QAAlB,CACA,IAAM5F,EAAO4F,EAAEtD,IAIf,IAHe7H,IAAkB4H,MAAK,SAAA6D,GACpC,OAAON,EAAEC,iBAAiBK,MAG5B,OAAoB,IAAhBlG,EAAK9E,QAAyB,cAAT8E,GACvBkF,EAAS,CAAEzC,KAAM,SAAUzC,OAAMiC,KAAMkE,KAAKC,aAC5CR,EAAES,uBAFJ,IAgCIC,QAzBN,SAAeV,GACbX,EAAWW,EAAG,MACdD,EAAiBC,IAwBbrC,MAAO,CAACgD,OAAQ,EAAGC,QAAS,EAAGC,OAAQ,EAAG9D,SAAU,YACpD+D,QAAS,kBAAMnB,GAAc,IAC7BoB,OAAQ,kBAAMpB,GAAc,MAE9B,mBAAGhC,MAAO,CAACI,WAAY6B,EAAW,UAAY,UAA9C,gCAGA,qBAAK1C,UAAU,aAAaS,MAAO,CACjCgD,OAAQR,EAAmB,KAC3BlK,MAAOwF,EAAOxF,MAAQT,YAAS,IAAKiG,IAFtC,SAIE,sBACEyB,UAAU,QACVpE,QAAS,kCAAM0G,EAASlB,eAAf,aAAM,EAAkBwB,SACjCnC,MAAO,CAAEE,UAAU,mBAHrB,UAKGqC,EAAarB,KAAI,mCAAE9J,EAAF,KAAQM,EAAR,YAChBN,GAAQ,cAAC,EAAD,CAENA,KAAMA,EACNM,MAAOA,GAFFN,MAKT,cAAC,EAAD,CAAOgI,SAAUf,EAAOgB,QAAS0C,a,qECZ5BsB,MA7Ef,WACE,IAAMhI,EAAQiE,IACNpE,EAA2BG,EAA3BH,QAASxD,EAAkB2D,EAAlB3D,MAAOoG,EAAWzC,EAAXyC,OAElBwF,EA2ER,SAAoBlM,EAAcM,GAChC,IAAIwG,EAAU,EAAGqF,EAAY,EAAGC,EAAU,EAAGC,EAAS,EAiBtD,OAhBA/K,IACEvB,YAASC,GACTD,YAASO,IACToB,SAAQ,YAAsB,IAAD,mBAAnB4K,EAAmB,KAAZC,EAAY,KAC7BjL,IACElB,YAASkM,GACTlM,YAASmM,IACT7K,SAAQ,YAAwB,IAAD,mBAArB8K,EAAqB,KAAbC,EAAa,KAC1BD,GAAQH,IACRI,EACID,IAAWC,EAAS3F,IACxBqF,IAFSC,OAIhBtF,OAGK,CAACA,UADRA,EACiBqF,YAAWC,UAASpF,MAAOqF,GA7F7BK,CAAW5I,EAAQ9D,KAAMM,GAClCqM,EAAY1I,EAAME,SAAS,GAAGG,UAC9BsI,GAAYvI,IAAKJ,EAAME,UAAWG,UAAYqI,GAAa,IAE3DE,EAAY9J,IAAMqG,SAAQ,WAE9B,IAAM0D,EAAOC,MACVnH,KAAK,CAAErF,OAAQoC,KAAKqK,MAAMJ,KAC1B9C,KAAI,SAACmD,EAAG9J,GACP,MAAO,CACL+J,OAAQ/J,EAAQ,EAChBgK,IAAKC,EAASnJ,EAAOd,GACrBkK,IAAKC,EAAWrJ,EAAOd,GACvB2B,OAAQyI,EAAWtJ,EAAOd,GAC1B7C,MAAOkN,EAAWvJ,EAAOd,OAI/B,OADAkB,IAAKyI,GAAOI,OAASN,EACdE,IACN,CAAC7I,EAAO2I,IAELa,EAAM1K,IAAMqG,SAAQ,WACxB,IAAMsE,EAAQ3N,YAAS+D,EAAQ9D,MAAMuC,KAAK,IAAIhC,OAI9C,OAA8B,KAAtB,EAHOsM,EAAUc,QAAO,SAACC,EAAKC,GAAN,OAC9BA,EAAE/I,OAAS8I,EAAMC,EAAE/I,OAAS8I,IAC3B,GACkBF,KACpB,CAACb,EAAW/I,IAEf,OACE,sBAAKqE,UAAU,QAAf,UACE,sBAAKA,UAAU,MAAf,UACE,qCACA,6BAAKxF,KAAKqK,MAAMnI,EAAOZ,SAEzB,sBAAKkE,UAAU,MAAf,UACE,qCACA,+BAAKxF,KAAKqK,MAAMS,GAAhB,UAEF,qBAAKtF,UAAU,QAAf,SACE,eAAC2F,EAAA,EAAD,CAAe5M,MAAsB,GAAfwF,EAAOxF,MAAY0K,OAAQ,IAAKkB,KAAMD,EAA5D,UACE,cAAC,IAAD,CAAM/E,KAAK,WAAWiG,QAAQ,MAAMC,QAAQ,MAAMC,OAAO,UAAUC,KAAK,YACxE,cAAC,IAAD,CAAMpG,KAAK,WAAWiG,QAAQ,MAAMC,QAAQ,MAAMC,OAAO,MAAMC,KAAK,QACpE,cAACC,EAAA,EAAD,CAASrG,KAAK,WAAWiG,QAAQ,SAASC,QAAQ,SAASC,OAAO,QAAQC,KAAK,SAC/E,cAACE,EAAA,EAAD,CAAeH,OAAO,QAAQI,gBAAgB,QAC9C,cAACC,EAAA,EAAD,CACExG,KAAK,SACLkG,QAAQ,SACRO,UAAW,GACXC,OAAQ,CAAC,EAAG,WACZC,eAAe,IAEjB,cAACC,EAAA,EAAD,CAAOX,QAAQ,QACf,cAACW,EAAA,EAAD,CAAOX,QAAQ,SAASY,YAAY,QAAQF,eAAe,IAC3D,cAACG,EAAA,EAAD,SAGJ,sBAAKzG,UAAU,MAAf,UACE,qCACA,6BAAKxF,KAAKqK,MAAMvI,EAAOR,SAEzB,sBAAKkE,UAAU,QAAf,UACE,4CACA,+BAAK+D,EAAOpF,QAAZ,IAAsBoF,EAAOC,UAA7B,IAAyCD,EAAOlF,MAAhD,IAAwDkF,EAAOE,cAEjE,sBAAKjE,UAAU,OAAf,UACE,sCACA,+BAAKxF,KAAKqK,MAAMJ,GAAhB,cA6BR,SAASU,EAAWrJ,EAAoBiJ,GACtC,IAAMP,EAAY1I,EAAME,SAAS,GAAGG,UAChChC,EAAQiC,EACVN,EACA0I,EAA2B,KAAdO,EAAS,GACtBP,EAA2B,KAAdO,EAAS,IACtB,GAEF,GAAqB,IAAjB5K,EAAM/B,OAAc,OAAO,EAC/B,IACMiE,EAAK,CAAElE,MADC+D,IAAK/B,GAAQhC,MACPwD,QAASG,EAAMH,QAASK,SAAU7B,GACtD,OAAOK,KAAKqK,MAAMvI,EAAOD,IAG3B,SAAS4I,EAASnJ,EAAoBiJ,GACpC,IAAMP,EAAY1I,EAAME,SAAS,GAAGG,UAChChC,EAAQiC,EACVN,EACA0I,EACAA,EAA2B,KAAdO,EAAS,IACtB,GAEF,GAAqB,IAAjB5K,EAAM/B,OAAc,OAAO,EAC/B,IACMiE,EAAK,CAAElE,MADC+D,IAAK/B,GAAQhC,MACPwD,QAASG,EAAMH,QAASK,SAAU7B,GACtD,OAAOK,KAAKqK,MAAMnI,EAAOL,IAG3B,SAAS+I,EAAWtJ,EAAoBiJ,GACtC,IAAMP,EAAY1I,EAAME,SAAS,GAAGG,UAChChC,EAAQiC,EACVN,EACA0I,EAAqB,IAATO,EACZP,EAA2B,KAAdO,EAAS,IACtB,GAEF,OAAqB,IAAjB5K,EAAM/B,OAAqB,KACxB+B,EAAMqL,QAAO,SAACkB,EAAMC,GACzB,OAAOD,EAAOE,OAAOxJ,EAAa,CAChCjF,MAAOwO,EAAKxO,MACZwD,QAASG,EAAMH,aAEhB,IAAM,KAGX,SAAS0J,EAAWvJ,EAAoBiJ,GACtC,IAAMP,EAAY1I,EAAME,SAAS,GAAGG,UAChChC,EAAQiC,EACVN,EACA0I,EACAA,EAA2B,KAAdO,EAAS,IACtB,GAEF,OAAqB,IAAjB5K,EAAM/B,OAAqB,GACxB8D,IAAK/B,GAAQhC,MClJP0O,MARf,YAAyC,IAAtB1E,EAAqB,EAArBA,WAGjB,MAAkB,UAFCpC,IAAX5B,OAGA,cAAC,EAAD,IACA,cAAC,EAAD,CAAYgE,WAAYA,KCR5B2E,EACJlM,IAAMmM,cAA2B/I,EAAK,CAAEnG,KAAM,MAC1CmP,EACJpM,IAAMmM,cAAwD,MAUzD,SAASE,EAAT,GAMI,IALT9O,EAKQ,EALRA,MACAwD,EAIQ,EAJRA,QACAH,EAGQ,EAHRA,OAGQ,IAFR2G,kBAEQ,MAFK,kBAAM,GAEX,MADR+E,8BACQ,WACkBtM,IAAMuM,WAAWzH,EAAS,MAAM,kBAAM1B,EAAKrC,MAD7D,mBACDG,EADC,KACMsG,EADN,KAGRxH,IAAMM,WAAU,WACdkH,EAAS,CAAEzC,KAAM,OAAQhE,UAASuC,MAAOgJ,MACxC,CAACvL,EAASuL,IAEbtM,IAAMM,WAAU,WACT/C,GACLiK,EAAS,CAAEzC,KAAM,QAAS7D,MAAO,CAAE3D,aAClC,CAACA,IAEJ,IAAM6J,EAAYpH,IAAM2H,OAAsB,MAO9C,OANA3H,IAAMM,WAAU,WACTM,GAAUwG,EAAUZ,UAAYtF,EAAO3D,QAClB,OAAtB6J,EAAUZ,SAAkB5F,EAAOM,GACvCkG,EAAUZ,QAAUtF,EAAO3D,SAC1B,CAAC2D,EAAON,IAGT,cAACwL,EAAgBI,SAAjB,CAA0BC,MAAOjF,EAAjC,SACE,cAAC0E,EAAaM,SAAd,CAAuBC,MAAOvL,EAA9B,SACE,cAAC,EAAD,CAASqG,WAAYA,QAMtB,SAASpC,IACd,OAAOnF,IAAM0M,WAAWR,GAGnB,SAASzE,IACd,OAAOzH,IAAM0M,WAAWN,GAG1B,SAAShJ,EAAKrC,GACZ,OAAO+D,EAAQ,KAAM,CAAEC,KAAM,OAAQhE,UAASuC,OAAO","file":"static/js/6.896ad15e.chunk.js","sourcesContent":["import zip from 'lodash/zip';\n\nexport const IGNORED_CHARACTERS = ['', 'Backspace'];\nexport const IGNORED_MODIFIERS = ['Alt', 'AltGraph', 'Control', 'Fn', 'Meta', 'OS']\n\nexport const getWords = (text = '') => {\n  return text.split(' ').filter(w => w);\n}\n\nexport const getChars = (text = '') => {\n  return text.split('');\n}\n\nexport const getExtra = (text: string, typed = '') => {\n  if (typed.length > text.length)\n    return typed.substr(text.length);\n  return '';\n}\n\nexport const withExtra = (text: string, typed: string) => {\n  const wtext = getWords(text);\n  const wtyped = getWords(typed);\n  return zip(wtext, wtyped).map(([text, typed]) => {\n    return text + getExtra(text!, typed);\n  }).join(' ');\n}\n\nexport const getWidth = (\n  text: string, \n  {fontFamily, fontSize}: {fontFamily: string, fontSize: number}\n) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context!.font = `${fontSize}px ${fontFamily}`;\n  return context!.measureText(text).width;\n}\n\nexport const getLines = (\n  text: string, \n  typed: string, \n  { width }: { width: number }\n) => {\n  const typedWords = getWords(typed)\n  const words = zip(\n    getWords(text),\n    typedWords,\n  )\n  let currentLength = 0;\n  let currentLine: [string, string] = ['', '']\n  const lines: [string, string][] = [];\n  words.forEach(([word, typed]) => {\n    if (!word) return;\n    let wlength = word.length;\n    if (typed && typed.length > word.length) wlength = typed.length;\n    if (currentLength + 1 + wlength > width) {\n      currentLength = wlength;\n      lines.push([\n        currentLine[0].trim(),\n        currentLine[1].trim()\n      ]);\n      currentLine = [word, typed || '']\n    } else {\n      currentLength += 1 + wlength;\n      currentLine[0] += ' ' + word;\n      if (typed) currentLine[1] += ' ' + typed;\n    }\n  });\n  if (currentLine.length > 0) lines.push(currentLine);\n  return lines;\n}\n\nexport const getCaretPosition = (lines: string[], typed: string): [number, number] => {\n  const words = getWords(typed);\n  let wcount = 0;\n  const lineIndex = lines.findIndex(line => {\n    const lwords = getWords(line);\n    if (wcount + lwords.length >= words.length) return true;\n    wcount += lwords.length;\n    return false;\n  });\n  const lastWords = words.slice(wcount);\n  let charIndex = lastWords.join(' ').length;\n  if (typed.endsWith(' ')) charIndex++;\n  return [charIndex, lineIndex];\n}","import React from 'react';\nimport { Typer } from '../../components/Typer';\n\nconst QUOTES_URL = process.env.REACT_APP_QUOTES_URL!;\n\nfunction Quotes() {\n  const [quotes, setQuotes] = React.useState<Typer.Content[]>([]);\n  const [index, setIndex] = React.useState(-1);\n\n  React.useEffect(() => {\n    fetch(QUOTES_URL)\n      .then(r => r.json())\n      .then(({ quotes }) => {\n        setQuotes(quotes);\n        setIndex(rand(quotes.length));\n      });\n  }, [])\n\n  const onType = React.useCallback(t => {\n    // console.log(t);\n  }, []);\n\n  if (index === -1) return <div>Loading...</div>;\n\n  return (\n    <>\n      <Typer content={quotes[index]} onType={onType}/>\n      <button onClick={() => setIndex(rand(quotes.length))}>Next</button>\n    </>\n  );\n}\n\nexport default Quotes;\n\n\nfunction rand(count: number) {\n  return Math.floor(Math.random() * count);\n}","import zip from 'lodash/zip';\nimport last from 'lodash/last'\nimport { getChars, getExtra, getWords, IGNORED_CHARACTERS } from \"./text\";\n\nexport function didType(state: Typer.State, str: string) {\n  const { typed, content } = state;\n  const startIndex = content.text.indexOf(str);\n  if (startIndex === -1)\n    throw Error('string not found in text');\n  const endIndex = startIndex + str.length;\n  const substr = content.text.substr(0, endIndex);\n  const subWords = getWords(substr);\n  const typedWords = getWords(typed);\n  return typedWords.length >= subWords.length;\n}\n\nexport function wordStats(state: Typer.State, wordIndex: number) {\n  const { typed, content } = state;\n  const stats = { left: 0, correct: 0, extra: 0, wrong: 0 }\n  const word = getWords(content.text)[wordIndex];\n  const typedWord = getWords(typed)[wordIndex];\n  if (!typedWord) {\n    stats.left = word.length;\n    return stats;\n  }\n  zip(\n    getChars(word),\n    getChars(typedWord),\n  ).forEach(([char, typedChar]) => {\n    if (!typedChar) stats.left++;\n    else if (char === typedChar) stats.correct++;\n    else stats.wrong++;\n  });\n  const extraStr = getExtra(word, typedWord);\n  getChars(extraStr).forEach(() => {\n    stats.extra++;\n  });\n  return stats;\n}\n\nexport function lastWpm(state: Typer.State, milis = 5000) {\n  if (state.timeline.length === 0) return 0;\n  const endTime = last(state.timeline)!.timestamp;\n  let slice = timeSlice(\n    state, \n    endTime - milis,\n    endTime + 1000,\n    false\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice)!.typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return rawWpm(st);\n}\n\nexport function isDoneTyping({ typed, content }: Typer.State) {\n  const typedWords = getWords(typed);\n  const allWords = getWords(content.text);\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}\n\nexport function netWpm(state: Pick<Typer.State, 'timeline' | 'content' | 'typed'>) {\n  return rawWpm(state) - unfixedErrors(state) / typedMilis(state) * 1000 * 60;\n}\n\nexport function rawWpm(state: Pick<Typer.State, 'timeline'>) {\n  return typedCount(state) / typedMilis(state) * 1000 * 60 / 5;\n}\n\nexport function typedCount(state: Pick<Typer.State, 'timeline'>) {\n  return state.timeline\n    .filter(i => !IGNORED_CHARACTERS.includes(i.char))\n    .length;\n}\n\nexport function typedMilis(state: Pick<Typer.State, 'timeline'>) {\n  if (state.timeline.length === 0) return 0;\n  return last(state.timeline)!.timestamp - state.timeline[0].timestamp;\n}\n\nexport function unfixedErrors(state: Pick<Typer.State, 'typed' | 'content'>) {\n  let errors = 0;\n  const typedWords = getWords(state.typed);\n  zip(\n    typedWords,\n    getWords(state.content.text),\n  ).forEach(([typedWord, word], index) => {\n    if (!word || !typedWord) return; // should not happen\n    if (index < typedWords.length -1 && word.length > typedWord!.length) {\n      errors++; // all missings as one error\n    }\n    zip(\n      getChars(typedWord),\n      getChars(word),\n    ).forEach(([typedChar, char]) => {\n      if (char === typedChar) return;\n      errors++; // extras and incorrects\n    });\n  });\n  return errors;\n}\n\nexport function groupTimeline(\n  state: Typer.State, \n  groupMilis: number = 1000\n): Typer.TimelineItem[][] {\n  let groups: Typer.TimelineItem[][] = [];\n  let [firstItem, ...rest] = state.timeline;\n  let prevTimestamp = firstItem.timestamp;\n  let accumTime = 0;\n  let currentGroup = [firstItem];\n  rest.forEach(item => {\n    accumTime += item.timestamp - prevTimestamp;\n    prevTimestamp = item.timestamp;\n    currentGroup.push(item);\n    while (accumTime >= groupMilis) {\n      accumTime -= groupMilis;\n      groups.push(currentGroup);\n      currentGroup = [];\n    }\n  });\n  if (currentGroup.length > 0) {\n    const groupTime = last(currentGroup)!.timestamp - currentGroup[0].timestamp;\n    if (groupTime < groupMilis / 2 && groups.length > 0) {\n      last(groups)!.push(...currentGroup);\n    } else {\n      groups.push(currentGroup);\n    }\n  }\n  return groups;\n}\n\nexport function mistypedLast(\n  state: Pick<Typer.State, 'typed' | 'content'>\n) {\n  const { typed, content } = state;\n  if (!typed) return false;\n  const char = last(typed)!;\n  if (IGNORED_CHARACTERS.includes(char)) return false;\n\n  const wordsTyped = getWords(typed);\n  const lastWord = last(wordsTyped)!;\n  const actualWord = getWords(content.text)[wordsTyped.length - 1];\n\n  // it'd be like that sometimes\n  if (!actualWord) return false;\n\n  if (typed.endsWith(' ')) {\n    // not extra, missing\n    const missing = actualWord.length - lastWord.length;\n    return missing > 0;\n  }\n\n  const lastChar = lastWord[lastWord.length - 1];\n  const actualChar = actualWord[lastWord.length - 1];\n  return actualChar !== lastChar;\n}\n\nexport function timeSlice(\n  state: Typer.State, \n  from: number, \n  to: number,\n  overtime: boolean = false\n) {\n  let start = state.timeline.findIndex(i => i.timestamp >= from);\n  let end = state.timeline.findIndex(i => i.timestamp >= to);\n  if (start === -1) start = 0;\n  if (end === -1) end = state.timeline.length - 1;\n  if (overtime) {\n    if (start > 0) start--;\n    if (end < state.timeline.length - 1) end++;\n  }\n  return state.timeline.slice(start, end);\n}","function merge(state: Typer.State, action: Typer.Actions.Merge): Typer.State {\n  let diff = Object.entries(action.state)\n    .some(([key, val]) => state[key] !== val);\n  if (!diff) return state;\n  return {\n    ...state,\n    ...action.state,\n  }\n}\n\nexport default merge;","import init from './init';\nimport typing from './typing';\nimport screen from './screen';\nimport merge from './merge';\n\nconst ducers = {\n  init,\n  typing,\n  screen,\n  merge,\n};\n\nexport default function reducer(\n  state: Typer.State | null, \n  action: Typer.Actions.Any) \n{\n  const r = ducers[action.type] as Reducer;\n  if (!r) return state;\n  return r(state, action);\n}\n\ntype Reducer = (state: Typer.State | null, action: Typer.Actions.Any) => Typer.State;","export default function init(\n  state: Typer.State | null, \n  action: Typer.Actions.Init\n): Typer.State {\n  if (!action.reset) {\n    return {\n      ...state!,\n      content: action.content,\n      timeline: []\n    }\n  }\n  return {\n    content: action.content,\n    typed: '',\n    screen: 'typing',\n    temp: {\n      prevTime: 0,\n      delta: 0,\n      errors: 0,\n      count: 0\n    },\n    timeline: [],\n    config: {\n      fontFamily: 'monospace',\n      fontSize: 24,\n      lineHeight: 30,\n      width: 60, \n      colors: {\n        left: 'gray',\n        correct: 'white',\n        wrong: 'red',\n        extra: 'darkred',\n        caret: 'cyan'\n      }\n    }\n  }\n}","import { isDoneTyping } from '../util/handlers';\nimport { IGNORED_CHARACTERS } from '../util/text';\n\nconst typing = (\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) => {\n  let newState = setTyped(state, action);\n  newState = addToTimeline(newState, action);\n  return setDone(newState);\n}\n\nexport default typing;\n\nfunction setTyped(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  let { typed } = state;\n  // dont add spaces together\n  if (char === ' ' && typed.endsWith(' ')) return state;\n  if (char === 'Backspace')\n    typed = typed.substr(0, typed.length - 1);\n  else typed = typed + char;\n  return { ...state, typed };\n}\n\nfunction addToTimeline(\n  state: Typer.State,\n  { char, time }: Typer.Actions.Typing\n) {\n  if (!state.typed) {\n    if (IGNORED_CHARACTERS.includes(char)) return state;\n  }\n  return {\n    ...state,\n    timeline: [\n      ...state.timeline,\n      { timestamp: time, char, typed: state.typed }\n    ]\n  };\n}\n\nfunction setDone(state: Typer.State) {\n  if (isDoneTyping(state))\n    return {\n      ...state,\n      screen: 'stats'\n    }\n  return state;\n}\n","export default function screen(\n  state: Typer.State, \n  action: Typer.Actions.Screen\n): Typer.State {\n  return {\n    ...state,\n    screen: action.screen\n  }\n}","import React from 'react';\nimport { getWidth } from '../util/text';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  position: [number, number];\n  focused: boolean;\n}\n\nfunction Caret({ position, focused }: Props) {\n  const { config, typed } = useTyper();\n  const [className, setClassName] = React.useState('caret');\n\n  React.useEffect(() => {\n    setClassName('caret');\n    const timeoutId = setTimeout(() => {\n      setClassName('caret animated');\n    }, 500);\n    return () => clearTimeout(timeoutId);\n  }, [typed]);\n\n  if (!position) return null;\n  const [x, y] = position;\n  const charWidth = getWidth('a', config);\n  const clampedY = y ? 1 : 0;\n  return (\n    <span \n      className={className}\n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        transform: `translate(${x * charWidth + 3}px, ${clampedY * config.lineHeight + 5}px)`,\n        color: config.colors.caret,\n        visibility: focused ? 'visible' : 'hidden'\n      }}\n    >|\n    </span>\n  );\n} \n\nexport default Caret;","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  text?: string;\n  typed?: string;\n}\n\nconst Char = React.memo(function Char({ text, typed }: Props) {\n  const { config } = useTyper();\n  const code = React.useMemo(() => {\n    if (!typed) return 'left';\n    if (!text) return 'extra';\n    if (typed === text) return 'correct';\n    return 'wrong';\n  }, [text, typed]);\n  const color = config.colors[code]\n  const str = text || typed;\n  const className = ['Char', code].join(' ')\n  return (\n    <span className={className} style={{color}}>{str}</span>\n  );\n});\n\nexport default Char;","import React from \"react\";\nimport zip from 'lodash/zip';\nimport Char from \"./Char\";\nimport { useTyper } from \"./Typer\";\nimport { getChars, getWidth } from \"../util/text\";\nimport '../styles/Word.css';\n\ninterface Props {\n  text: string;\n  typed?: string;\n  current: boolean;\n}\n\nconst Word = React.memo(function Word({ text, typed, current }: Props) {\n  const { config } = useTyper();\n  const _chars = zip(\n    getChars(text),\n    getChars(typed),\n  );\n  const redline = !current && typed && text !== typed;\n  const className = [\n    \"Word\", \n    redline && 'redline',\n    current && 'current'\n  ].filter(c => c).join(' ');\n  const space = getWidth(' ', config);\n  return (\n    <div \n      className={className} \n      style={{\n        marginRight: space, \n        borderBottomColor: redline ? config.colors.wrong : 'transparent'\n      }}\n    >\n      {_chars.map(([text, typed], index) => \n        <Char \n          key={index}\n          text={text}\n          typed={typed}\n        />\n      )}\n    </div>\n  );\n});\n\nexport default Word;","import React from 'react';\nimport zip from 'lodash/zip';\nimport { getWords } from '../util/text';\nimport Word from './Word';\nimport '../styles/Line.css';\n\ninterface Props {\n  text: string;\n  typed: string;\n}\n\nconst Line = React.memo(function Line({ text, typed }: Props) {\n  const typedWords = getWords(typed);\n  const words = zip(\n    getWords(text),\n    typedWords,\n    [undefined, ...typedWords],\n    typedWords.slice(1)\n  )\n\n  function isCurrent(word?: string, prev?: string, next?: string) {\n    if (!typed && !prev) return true;\n    if (typed.endsWith(' ')) return prev != null && word == null;\n    return word != null && next == null;\n  }\n\n  return (\n    <div className=\"Line\">\n      {words.map(([text, typedWord, prevTyped, nextTyped], index) => \n        text && <Word\n          key={index}\n          text={text} \n          typed={typedWord}\n          current={isCurrent(typedWord, prevTyped, nextTyped)} \n        />\n      )}\n    </div>\n  );\n});\n\nexport default Line;","import React from 'react';\nimport { getCaretPosition, getLines, getWidth, IGNORED_MODIFIERS } from '../util/text'\nimport { useTyper, useTyperDispatch } from './Typer'\nimport Caret from './Caret';\nimport '../styles/TypingTest.css';\nimport Line from './Line';\n\ninterface Props {\n  onKeyPress(\n    e: React.KeyboardEvent<HTMLInputElement>,\n    direction: 'up' | 'down'\n  ): boolean;\n}\n\nfunction TypingTest({ onKeyPress }: Props) {\n  const { content, typed, config } = useTyper();\n  const dispatch = useTyperDispatch();\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [inputHasFocus, setInputFocus] = React.useState(false);\n  const [capslock, setCapslock] = React.useState(false);\n\n  React.useEffect(() => {\n    inputRef.current?.focus();\n  }, [content.text]);\n\n  const lines = React.useMemo(() => {\n   return getLines(content.text, typed, config); \n  }, [typed, content, config]);\n\n  const caret = React.useMemo(() => {\n    return getCaretPosition(lines.map(([t]) => t), typed);\n  }, [lines, typed]);\n\n  function keyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    capslockDetector(e);\n    if (onKeyPress(e, 'down')) return;\n    const char = e.key;\n    const ignore = IGNORED_MODIFIERS.some(mod => {\n      return e.getModifierState(mod);\n    })\n    if (ignore) return;\n    if (char.length === 1 || char === 'Backspace') {\n      dispatch({ type: 'typing', char, time: Date.now() });\n      e.preventDefault();\n      return;\n    }\n  }\n\n  function keyUp(e: React.KeyboardEvent<HTMLInputElement>) {\n    onKeyPress(e, 'up');\n    capslockDetector(e);\n  }\n\n  function capslockDetector(e: React.KeyboardEvent<HTMLInputElement>) {\n    setCapslock(e.getModifierState('CapsLock'));\n  }\n\n  const drawingLines = React.useMemo(() => {\n    if (caret[1] < 2) return lines.slice(0, 3);\n    return lines.slice(caret[1] - 1, caret[1] + 2);\n  }, [lines, caret]);\n\n  const threeLinesHeight = config.lineHeight * 3 + 10 // 10px padding\n\n  return (\n    <div className=\"TypingTest\" style={{\n      fontFamily: config.fontFamily,\n      fontSize: config.fontSize + 'px',\n      lineHeight: (config.lineHeight - 1) + 'px', // 1px border bottom\n    }}>\n      <input \n        ref={inputRef}\n        onKeyDown={keyDown}\n        onKeyUp={keyUp}\n        style={{height: 0, padding: 0, border: 0, position: \"absolute\"}}\n        onFocus={() => setInputFocus(true)}\n        onBlur={() => setInputFocus(false)}\n      />\n      <p style={{visibility: capslock ? \"visible\" : \"hidden\"}}>\n        CAPSLOCK IS ACTIVE\n      </p>\n      <div className=\"threeLines\" style={{\n        height: threeLinesHeight + 'px',\n        width: config.width * getWidth('a', config)\n      }}>\n        <div \n          className=\"words\" \n          onClick={() => inputRef.current?.focus()}\n          style={{ transform: `translateY(0px)`}}\n        >\n          {drawingLines.map(([text, typed]) => \n            text && <Line\n              key={text}\n              text={text} \n              typed={typed}\n            />\n          )}\n          <Caret position={caret} focused={inputHasFocus} />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default TypingTest;\n","import React from 'react';\nimport last from 'lodash/last';\nimport zip from 'lodash/zip';\nimport { ComposedChart, Line, Scatter, CartesianGrid, XAxis, YAxis, Tooltip } from 'recharts';\nimport { netWpm, rawWpm, mistypedLast, timeSlice } from '../util/handlers';\nimport { getChars, getWords } from '../util/text';\nimport { useTyper } from './Typer';\nimport '../styles/Stats.css';\n\nfunction Stats() {\n  const state = useTyper();\n  const { content, typed, config } = state;\n\n  const counts = charCounts(content.text, typed);\n  const startTime = state.timeline[0].timestamp;\n  const duration = (last(state.timeline)!.timestamp - startTime) / 1000;\n\n  const chartData = React.useMemo(() => {\n    debugger;\n    const data = Array\n      .from({ length: Math.round(duration)  })\n      .map((_, index) => {\n        return { \n          second: index + 1, \n          wpm: wpmPoint(state, index),\n          raw: slicePoint(state, index), \n          errors: errorPoint(state, index),\n          typed: typedPoint(state, index)\n        };\n      });\n    last(data)!.second = duration;\n    return data;\n  }, [state, duration]);\n\n  const acc = React.useMemo(() => {\n    const total = getWords(content.text).join('').length;\n    const errors = chartData.reduce((sum, d) => (\n      d.errors ? sum + d.errors : sum\n    ), 0)\n    return (1 - errors / total) * 100;\n  }, [chartData, content]);\n\n  return (\n    <div className=\"Stats\">\n      <div className=\"wpm\">\n        <h3>wpm</h3>\n        <h2>{Math.round(netWpm(state))}</h2>\n      </div>\n      <div className=\"acc\">\n        <h3>acc</h3>\n        <h2>{Math.round(acc)}%</h2>\n      </div>\n      <div className=\"chart\">\n        <ComposedChart width={config.width * 15} height={300} data={chartData}>\n          <Line type=\"monotone\" yAxisId=\"wpm\" dataKey=\"raw\" stroke=\"darkred\" fill=\"darkred\"/>\n          <Line type=\"monotone\" yAxisId=\"wpm\" dataKey=\"wpm\" stroke=\"red\" fill=\"red\"/>\n          <Scatter type=\"monotone\" yAxisId=\"errors\" dataKey=\"errors\" stroke=\"black\" fill=\"gray\"/>\n          <CartesianGrid stroke=\"#fff3\" strokeDasharray=\"5 5\" />\n          <XAxis \n            type=\"number\" \n            dataKey=\"second\" \n            tickCount={10}\n            domain={[1, 'dataMax']}\n            allowDecimals={false}\n          />\n          <YAxis yAxisId=\"wpm\"/>\n          <YAxis yAxisId=\"errors\" orientation=\"right\" allowDecimals={false}/>\n          <Tooltip/>\n        </ComposedChart>\n      </div>\n      <div className=\"raw\">\n        <h3>raw</h3>\n        <h2>{Math.round(rawWpm(state))}</h2>\n      </div>\n      <div className=\"chars\">\n        <h3>characters</h3>\n        <h2>{counts.correct}/{counts.incorrect}/{counts.extra}/{counts.missing}</h2>\n      </div>\n      <div className=\"time\">\n        <h3>time</h3>\n        <h2>{Math.round(duration)}s</h2>\n      </div>\n    </div>\n  )\n}\n\nexport default Stats;\n\nfunction charCounts(text: string, typed: string) {\n  let correct = 0, incorrect = 0, missing = 0, extras = 0\n  zip(\n    getWords(text),\n    getWords(typed)\n  ).forEach(([wtext, wtyped]) => {\n    zip(\n      getChars(wtext),\n      getChars(wtyped)\n    ).forEach(([chtext, chtyped]) => {\n      if (!chtext) extras++;\n      if (!chtyped) missing++;\n      else if (chtext === chtyped) correct++;\n      else incorrect++;\n    });\n    correct++; // spaces\n  });\n  correct--; // does not end with space\n  return {correct, incorrect, missing, extra: extras }\n}\n\nfunction slicePoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime + (second - 1) * 1000,\n    startTime + (second + 2) * 1000,\n    true\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice)!.typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return Math.round(rawWpm(st));\n}\n\nfunction wpmPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime,\n    startTime + (second + 1) * 1000,\n    true\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice)!.typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return Math.round(netWpm(st));\n}\n\nfunction errorPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime + second * 1000,\n    startTime + (second + 1) * 1000,\n    false\n  );\n  if (slice.length === 0) return null;\n  return slice.reduce((errs, item) => {\n    return errs + Number(mistypedLast({\n      typed: item.typed,\n      content: state.content\n    }));\n  }, 0) || null;\n}\n\nfunction typedPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime,\n    startTime + (second + 1) * 1000,\n    false\n  );\n  if (slice.length === 0) return '';\n  return last(slice)!.typed;\n}","import React from 'react';\nimport TypingTest from './TypingTest';\nimport Stats from './Stats';\nimport { useTyper } from './Typer';\n\ninterface Props {\n  onKeyPress(e: React.KeyboardEvent<HTMLInputElement>, direction: 'up' | 'down'): boolean;\n}\n\nfunction Screens({ onKeyPress }: Props) {\n  const { screen } = useTyper();\n\n  return screen === 'stats' \n        ? <Stats />\n        : <TypingTest onKeyPress={onKeyPress} />;\n}\n\nexport default Screens;","import React from 'react';\nimport reducer from '../reducers';\nimport Screens from './Screens';\n\nexport * from '../util/handlers';\n\nconst StateContext = \n  React.createContext<Typer.State>(init({ text: '' })!);\nconst DispatchContext = \n  React.createContext<React.Dispatch<Typer.Actions.Any> | null>(null);\n\ninterface Props {\n  typed?: string;\n  content: Typer.Content;\n  restartOnContentChange?: boolean\n  onType?(state: Typer.State): void;\n  onKeyPress?(e: React.KeyboardEvent<HTMLInputElement>, direction: 'up' | 'down'): boolean\n}\n\nexport function Typer({ \n  typed, \n  content, \n  onType,\n  onKeyPress = () => false,\n  restartOnContentChange = true \n}: Props) {\n  const [state, dispatch] = React.useReducer(reducer, null, () => init(content));\n\n  React.useEffect(() => {\n    dispatch({ type: 'init', content, reset: restartOnContentChange });\n  }, [content, restartOnContentChange]);\n\n  React.useEffect(() => {\n    if (!typed) return;\n    dispatch({ type: 'merge', state: { typed }});\n  }, [typed])\n\n  const prevTyped = React.useRef<string | null>(null);\n  React.useEffect(() => {\n    if (!onType || prevTyped.current === state!.typed) return;\n    if (prevTyped.current !== null) onType(state!);\n    prevTyped.current = state!.typed;\n  }, [state, onType]);\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state!}>\n        <Screens onKeyPress={onKeyPress}/>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n\nexport function useTyper() {\n  return React.useContext(StateContext);\n}\n\nexport function useTyperDispatch() {\n  return React.useContext(DispatchContext)!;\n}\n\nfunction init(content: Typer.Content) {\n  return reducer(null, { type: 'init', content, reset: true });\n}"],"sourceRoot":""}
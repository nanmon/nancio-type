{"version":3,"sources":["pages/yoshi/audios/1.wav","pages/yoshi/audios/2.wav","pages/yoshi/audios/3.wav","pages/yoshi/audios/4.wav","pages/yoshi/audios/5.wav","pages/yoshi/audios/6.wav","pages/yoshi/audios/7.wav","util/std.ts","util/text.ts","util/handlers.ts","reducers/typing.ts","reducers/index.ts","reducers/init.ts","reducers/screen.ts","components/Caret.tsx","components/Char.tsx","components/Word.tsx","components/TypingTest.tsx","components/Typer.tsx","hooks/typing-test.ts","components/Stats.tsx","components/Screens.tsx","pages/quotes/Quotes.tsx","pages/yoshi/Yoshi.tsx","pages/index.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["last","array","length","tuplify","firstItems","arrays","map","first","index","arr","avg","reduce","s","v","getWords","text","split","filter","w","getChars","getExtra","typed","substr","isDoneTyping","content","typedWords","allWords","endsWith","pop","mistype","state","char","includes","wordsTyped","lastWord","actualWord","lastChar","flushStats","newDelta","time","wpm","temp","count","stats","errs","errors","delta","prevTime","ducers","init","_state","action","screen","prevCount","config","fontFamily","fontSize","lineHeight","width","colors","left","correct","wrong","extra","caret","typing","fns","arg","rest","acc","fn","compose","newState","reducer","r","type","Caret","position","focused","useTyper","React","useState","className","setClassName","useEffect","timeoutId","setTimeout","clearTimeout","style","top","transform","x","y","color","visibility","Char","code","useMemo","str","join","Word","current","_chars","extraStr","forEach","push","redline","c","space","context","document","createElement","getContext","font","measureText","getWidth","marginRight","borderBottomColor","TypingTest","dispatch","useContext","DispatchContext","inputRef","useRef","inputHasFocus","setInputFocus","capslock","setCapslock","caretPosition","pos","setPos","wordEl","querySelector","originRect","getBoundingClientRect","wrect","charsTyped","querySelectorAll","rect","right","bottom","useCaret","focus","_words","slice","capslockDetector","e","getModifierState","offset","line","Math","floor","ref","onKeyDown","key","Date","now","preventDefault","onKeyUp","height","padding","border","onFocus","onBlur","onClick","maxWidth","word","prev","next","typedWord","prevTyped","nextTyped","Stats","counts","incorrect","missing","extras","wtext","wtyped","chtext","chtyped","charCounts","title","Screens","StateContext","createContext","Typer","onType","useReducer","Provider","value","Quotes","quotes","setQuotes","setIndex","fetch","then","json","rand","useCallback","t","random","min","max","audios","undefined","require","default","audioClamp","val","Yoshi","setContent","track","setTrack","setTimeoutId","refs","useLayoutEffect","audioProm","Promise","all","el","load","resolve","oncanplay","a","src","muted","preload","loop","avgWpm","lastWpm","play","id","pause","currentTime","Router","path","to","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"qMAAA,OAAe,cAA0B,+B,gCCAzC,OAAe,cAA0B,+B,gCCAzC,OAAe,cAA0B,+B,gCCAzC,OAAe,cAA0B,+B,gCCAzC,OAAe,cAA0B,+B,gCCAzC,OAAe,cAA0B,+B,gCCAzC,OAAe,cAA0B,+B,kICe5BA,G,YAAO,SAACC,GACnB,OAAOA,EAAMA,EAAMC,OAAS,KAgBjBC,EAAU,SAACC,GAA2C,IAAD,uBAApBC,EAAoB,iCAApBA,EAAoB,kBAChE,OAAOD,EAAWE,KAAI,SAACC,EAAOC,GAC5B,MAAM,CACJD,GADF,mBAEKF,EAAOC,KAAI,SAAAG,GAAG,OAAIA,EAAID,YA8CxB,SAASE,EAAIT,GAClB,OAAOA,EAAMU,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,IAAG,GAAKZ,EAAMC,OCjF3C,IAAMY,EAAW,WAAgB,IAAfC,EAAc,uDAAP,GAC9B,OAAOA,EAAKC,MAAM,KAAKC,QAAO,SAAAC,GAAC,OAAIA,MAGxBC,EAAW,WAAgB,IAAfJ,EAAc,uDAAP,GAC9B,OAAOA,EAAKC,MAAM,KAGPI,EAAW,SAACL,GAA8B,IAAhBM,EAAe,uDAAP,GAC7C,OAAIA,EAAMnB,OAASa,EAAKb,OACfmB,EAAMC,OAAOP,EAAKb,QACpB,IC8BF,SAASqB,EAAT,GAAwD,IAAhCF,EAA+B,EAA/BA,MAAOG,EAAwB,EAAxBA,QAC9BC,EAAaX,EAASO,GACtBK,EAAWZ,EAASU,EAAQT,MAClC,QAAIU,EAAWvB,OAASwB,EAASxB,YAC7BmB,EAAMM,SAAS,MACDF,EAAWG,QACZF,EAASE,OCmD5B,SAASC,EACPC,EADF,GAGG,IADCC,EACF,EADEA,KAEF,GAAI,CAAC,GAAI,aAAaC,SAASD,GAAO,OAAO,EAD7C,IAGQV,EAAmBS,EAAnBT,MAAOG,EAAYM,EAAZN,QACTS,EAAanB,EAASO,GACtBa,EAAWlC,EAAKiC,GAChBE,EAAarB,EAASU,EAAQT,MAAMkB,EAAW/B,OAAS,GAG9D,IAAKiC,EAAY,OAAO,EAExB,GAAId,EAAMM,SAAS,KACjB,OAAOQ,EAAWjC,OAASgC,EAAShC,OAEtC,IAAMkC,EAAWF,EAASA,EAAShC,OAAS,GAE5C,OADmBiC,EAAWD,EAAShC,OAAS,KAC1BkC,EAGxB,SAASC,EACPP,EADF,EAGEQ,GACC,IAFCC,EAEF,EAFEA,KAAMR,EAER,EAFQA,KAIFS,EAAMV,EAAMW,KAAKC,OADZ,EAAI,GAAK,GAEpB,OAAO,2BACFZ,GADL,IAEEa,MAAM,2BACDb,EAAMa,OADN,IAEHH,IAAI,GAAD,mBAAMV,EAAMa,MAAMH,KAAlB,CAAuBA,IAC1BI,KAAK,GAAD,mBAAMd,EAAMa,MAAMC,MAAlB,CAAwBd,EAAMW,KAAKI,WAEzCJ,KAAM,CACJK,MAAOR,EACPS,SAAUR,EACVG,MAAO,CAAC,GAAI,aAAaV,SAASD,GAAQ,EAAI,EAC9Cc,OAAQhB,EAAQC,EAAO,CAAEC,SAAU,EAAI,KCxI7C,IAAMiB,EAAS,CACbC,KCLa,SACbC,EACAC,GAEA,MAAO,CACL3B,QAAS2B,EAAO3B,QAChBH,MAAO,GACP+B,OAAQ,SACRT,MAAO,CACLD,MAAO,EACPW,UAAW,EACXb,IAAK,GACLK,OAAQ,EACRD,KAAM,IAERH,KAAM,CACJM,SAAU,EACVD,MAAO,EACPD,OAAQ,EACRH,MAAO,GAETY,OAAQ,CACNC,WAAY,YACZC,SAAU,GACVC,WAAY,GACZC,MAAO,IACPC,OAAQ,CACNC,KAAM,OACNC,QAAS,QACTC,MAAO,MACPC,MAAO,UACPC,MAAO,WDzBbC,OJKqB,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAAwB,SAACC,GAA8B,IAAD,uBAAhBC,EAAgB,iCAAhBA,EAAgB,kBAC3E,OAAOF,EAAIvD,QAAO,SAAC0D,EAAKC,GAAN,OAAaA,EAAE,WAAF,GAAGD,GAAH,OAAWD,MAAOD,IGL/BI,EAUpB,SACEzC,EADF,GAGG,IADCC,EACF,EADEA,KAEIV,EAAUS,EAAVT,MAEN,GAAa,MAATU,GAAgBV,EAAMM,SAAS,KAAM,OAAOG,EACnC,cAATC,EACFV,EAAQA,EAAMC,OAAO,EAAGD,EAAMnB,OAAS,GACpCmB,GAAgBU,EACrB,OAAO,2BAAKD,GAAZ,IAAmBT,aAGrB,SACES,EADF,GAGG,IADCC,EACF,EADEA,KAEF,MAAI,CAAC,GAAI,aAAaC,SAASD,GACtBD,EACF,2BACFA,GADL,IAEEa,MAAM,2BAAMb,EAAMa,OAAb,IAAoBD,MAAOZ,EAAMa,MAAMD,MAAQ,SAIxD,SACEZ,EACAqB,GAEA,OAAItB,EAAQC,EAAOqB,GACV,2BACFrB,GADL,IAEEa,MAAM,2BAAMb,EAAMa,OAAb,IAAoBE,OAAQf,EAAMa,MAAME,OAAS,MAEnDf,KAGT,SACEA,EADF,GAGG,IADCS,EACF,EADEA,KAAMR,EACR,EADQA,KAEAU,EAASX,EAATW,KACR,GAAsB,IAAlBA,EAAKM,SACP,OAAO,2BACFjB,GADL,IAEEW,KAAM,CACJK,MAAO,EACPC,SAAUR,EACVG,MAAO,CAAC,GAAI,aAAaV,SAASD,GAAQ,EAAI,EAC9Cc,OAAQhB,EAAQC,EAAO,CAAEC,SAAU,EAAI,KAI7C,IAAIe,EAAQL,EAAKK,OAASP,EAAOE,EAAKM,UACtC,GAAID,EAAQ,IACV,OAAO,2BACFhB,GADL,IAEEW,KAAM,CACJK,QACAC,SAAUR,EACVG,MAAgB,cAATX,EAAuBU,EAAKC,MAAQD,EAAKC,MAAQ,EACxDG,OAAQhB,EAAQC,EAAO,CAAEC,SAAUU,EAAKI,OAAS,EAAIJ,EAAKI,UAIhE,IAAI2B,EAAQ,eAAO1C,GACnB,KAAOgB,EAAQ,KAEb0B,EAAWnC,EAAWmC,EAAU,CAAEjC,OAAMR,QADxCe,GAAS,KAETf,EAAO,GAET,OAAOyC,KAGT,SAAiB1C,GACf,OAAIP,EAAaO,GACR,2BACFA,GADL,IAEEsB,OAAQ,UAELtB,KC1FPsB,OEPa,SACbtB,EACAqB,GAEA,OAAO,2BACFrB,GADL,IAEEsB,OAAQD,EAAOC,WFIJ,SAASqB,EACtB3C,EACAqB,GAEA,IAAMuB,EAAI1B,EAAOG,EAAOwB,MACxB,OAAKD,EACEA,EAAE5C,EAAOqB,GADDrB,E,WGuBF8C,MA9Bf,YAA8C,IAA7BC,EAA4B,EAA5BA,SAAUC,EAAkB,EAAlBA,QAAkB,EACjBC,IAAlBzB,EADmC,EACnCA,OAAQjC,EAD2B,EAC3BA,MAD2B,EAET2D,IAAMC,SAAS,SAFN,mBAEpCC,EAFoC,KAEzBC,EAFyB,KAY3C,OARAH,IAAMI,WAAU,WACdD,EAAa,SACb,IAAME,EAAYC,YAAW,WAC3BH,EAAa,oBACZ,KACH,OAAO,kBAAMI,aAAaF,MACzB,CAAChE,IAECwD,EAGH,sBACEK,UAAWA,EACXM,MAAO,CACLX,SAAU,WACVY,IAAK,EACL7B,KAAM,EACN8B,UAAU,aAAD,OAAeb,EAASc,EAAI,EAA5B,eAAoCd,EAASe,EAAI,EAAjD,OACTC,MAAOvC,EAAOK,OAAOK,MACrB8B,WAAYhB,EAAU,UAAY,UARtC,eAHoB,MCITiB,MAhBf,YAAuC,IAAvBhF,EAAsB,EAAtBA,KAAMM,EAAgB,EAAhBA,MACZiC,EAAWyB,IAAXzB,OACF0C,EAAOhB,IAAMiB,SAAQ,WACzB,OAAK5E,EACAN,EACDM,IAAUN,EAAa,UACpB,QAFW,QADC,SAIlB,CAACA,EAAMM,IACJwE,EAAQvC,EAAOK,OAAOqC,GACtBE,EAAMnF,GAAQM,EACd6D,EAAY,CAAC,OAAQc,GAAMG,KAAK,KACtC,OACE,sBAAMjB,UAAWA,EAAWM,MAAO,CAACK,SAApC,SAA6CK,K,MC4BlCE,MApCf,YAAgD,IAAhCrF,EAA+B,EAA/BA,KAAMM,EAAyB,EAAzBA,MAAOgF,EAAkB,EAAlBA,QACnB/C,EAAWyB,IAAXzB,OACFgD,EAASnG,EACbgB,EAASJ,GACTI,EAASE,IAELkF,EAAWnF,EAASL,EAAMM,GAChCF,EAASoF,GAAUC,SAAQ,SAAAzE,GACzBuE,EAAOG,KAAK,CAAC,KAAM1E,OAErB,IAAM2E,GAAWL,GAAWhF,GAASN,IAASM,EACxC6D,EAAY,CAChB,OACAwB,GAAW,UACXL,GAAW,WACXpF,QAAO,SAAA0F,GAAC,OAAIA,KAAGR,KAAK,KAChBS,ERJgB,SACtB7F,EADsB,GAGlB,IADHwC,EACE,EADFA,WAAYC,EACV,EADUA,SAGPqD,EADSC,SAASC,cAAc,UACfC,WAAW,MAElC,OADAH,EAASI,KAAT,UAAmBzD,EAAnB,cAAiCD,GAC1BsD,EAASK,YAAYnG,GAAM2C,MQHpByD,CAAS,IAAK7D,GAC5B,OACE,qBACE4B,UAAWA,EACXM,MAAO,CACL4B,YAAaR,EACbS,kBAAmBX,EAAUpD,EAAOK,OAAOG,MAAQ,eAJvD,SAOGwC,EAAOhG,KAAI,WAAgBE,GAAhB,uBAAEO,EAAF,KAAQM,EAAR,YACV,cAAC,EAAD,CAEEN,KAAMA,EACNM,MAAOA,GAFFb,S,MCwDA8G,MAtFf,WAAuB,IAAD,EACevC,IAA3BvD,EADY,EACZA,QAASH,EADG,EACHA,MAAOiC,EADJ,EACIA,OAClBiE,ECiCCvC,IAAMwC,WAAWC,GD/BlBC,EAAW1C,IAAM2C,OAAyB,MAJ5B,EAKmB3C,IAAMC,UAAS,GALlC,mBAKb2C,EALa,KAKEC,EALF,OAMY7C,IAAMC,UAAS,GAN3B,mBAMb6C,EANa,KAMHC,EANG,KAOdC,EEbD,SAAkB3G,EAAeiC,GAAuB,IAAD,EACtC0B,IAAMC,SAAqC,MADL,mBACrDgD,EADqD,KAChDC,EADgD,KAyB5D,OAtBAlD,IAAMI,WAAU,WACd,IAAM+C,EAASrB,SAASsB,cAAc,iBACtC,GAAKD,EAAL,CACA,IACME,EADUvB,SAASsB,cAAc,UACZE,wBACrBC,EAAQJ,EAAOG,wBACjBE,EAAaL,EAAOM,iBAAiB,oBACzC,GAA0B,IAAtBD,EAAWtI,OAAf,CAOA,IACMwI,EADO1I,EAAKwI,GACAF,wBAClBJ,EAAO,CACLvC,EAAG+C,EAAKC,MAAQN,EAAWzE,KAC3BgC,EAAG2C,EAAMK,OAASP,EAAW5C,IAAMnC,EAAOG,kBAV1CyE,EAAO,CACLvC,EAAG4C,EAAM3E,KAAOyE,EAAWzE,KAC3BgC,EAAG2C,EAAMK,OAASP,EAAW5C,IAAMnC,EAAOG,gBAU7C,CAACpC,EAAOiC,IAEJ2E,EFZeY,CAASxH,EAAOiC,GAEtC0B,IAAMI,WAAU,WAAO,IAAD,EACpB,UAAAsC,EAASrB,eAAT,SAAkByC,UACjB,CAACtH,EAAQT,OAEZ,IAAMU,EAAaX,EAASO,GACtB0H,EAAS5I,EACbW,EAASU,EAAQT,MACjBU,EAFoB,CAGnB,MAHmB,mBAGVA,IACVA,EAAWuH,MAAM,IAanB,SAASC,EAAiBC,GACxBnB,EAAYmB,EAAEC,iBAAiB,aASjC,IAAMC,EAASpE,IAAMiB,SAAQ,WAC3B,IAAK+B,EAAe,OAAO,EAC3B,IAAMqB,EAAOC,KAAKC,MAAMvB,EAAcpC,EAAItC,EAAOG,YACjD,OAAI4F,EAAO,EAAU,GACbA,EAAO,GAAK/F,EAAOG,aAC1B,CAACuE,EAAe1E,IAEnB,OACE,sBAAK4B,UAAU,aAAaM,MAAO,CACjCjC,WAAYD,EAAOC,WACnBC,SAAUF,EAAOE,SAAW,KAC5BC,WAAaH,EAAOG,WAAa,EAAK,MAHxC,UAKE,uBACE+F,IAAK9B,EACL+B,UAnCN,SAAoBP,GAClBD,EAAiBC,GACjB,IAAMnH,EAAOmH,EAAEQ,IACf,GAAoB,IAAhB3H,EAAK7B,QAAyB,cAAT6B,EAGvB,OAFAwF,EAAS,CAAE5C,KAAM,SAAU5C,OAAMQ,KAAMoH,KAAKC,aAC5CV,EAAEW,kBA+BAC,QAASb,EACTzD,MAAO,CAACuE,OAAQ,EAAGC,QAAS,EAAGC,OAAQ,EAAGpF,SAAU,YACpDqF,QAAS,kBAAMrC,GAAc,IAC7BsC,OAAQ,kBAAMtC,GAAc,MAE9B,mBAAGrC,MAAO,CAACM,WAAYgC,EAAW,UAAY,UAA9C,gCAGA,qBAAK5C,UAAU,aAAaM,MAAO,CAACuE,OAA4B,EAApBzG,EAAOG,WAAiB,MAApE,SACE,sBACEyB,UAAU,QACVkF,QAAS,kCAAM1C,EAASrB,eAAf,aAAM,EAAkByC,SACjCtD,MAAO,CAAE6E,SAAU/G,EAAOI,MAAOgC,UAAU,cAAD,QAAiB0D,EAAjB,QAH5C,UAKGL,EAAOzI,KAAI,WAA0CE,GAA1C,IApCD8J,EAAcC,EAAcC,EAoC3B,mBAAEzJ,EAAF,KAAQ0J,EAAR,KAAmBC,EAAnB,KAA8BC,EAA9B,YACV,cAAC,EAAD,CAEE5J,KAAMA,EACNM,MAAOoJ,EACPpE,SAzCOiE,EAyCYG,EAzCEF,EAyCSG,EAzCKF,EAyCMG,GAxC9CtJ,IAAUkJ,IACXlJ,EAAMM,SAAS,KAAqB,MAAR4I,GAAwB,MAARD,EACjC,MAARA,GAAwB,MAARE,KAmCRhK,MAMT,cAAC,EAAD,CAAOqE,SAAUmD,EAAelD,QAAS8C,aGtEpCgD,MAdf,WAAkB,IAAD,EACmB7F,IAA1BpC,EADO,EACPA,MAAOnB,EADA,EACAA,QAASH,EADT,EACSA,MAClBgD,EAAiD,KAA1C,EAAI1B,EAAME,OAASrB,EAAQT,KAAKb,QACvC2K,EAaR,SAAoB9J,EAAcM,GAChC,IAAIwC,EAAU,EAAGiH,EAAY,EAAGC,EAAU,EAAGC,EAAS,EAetD,OAdA7K,EACEW,EAASC,GACTD,EAASO,IACTmF,SAAQ,YAAsB,IAAD,mBAAnByE,EAAmB,KAAZC,EAAY,KAC7B/K,EACEgB,EAAS8J,GACT9J,EAAS+J,IACT1E,SAAQ,YAAwB,IAAD,mBAArB2E,EAAqB,KAAbC,EAAa,KAC1BA,EACID,IAAWC,EAASvH,IACxBiH,IAFSC,OAIhB5J,EAASC,EAAS6J,EAAOC,IAAS1E,SAAQ,kBAAMwE,UAE3C,CAACnH,UAASiH,YAAWC,UAAShH,MAAOiH,GA7B7BK,CAAW7J,EAAQT,KAAMM,GACxC,OACE,qCACE,sCAASX,EAAIiC,EAAMH,KAAnB,UACA,uCAAUG,EAAMH,IAAItC,OAApB,QACA,sCAASmE,EAAT,OACA,oBAAGiH,MAAM,kCAAT,oBAAmDT,EAAOhH,QAA1D,IAAoEgH,EAAOC,UAA3E,IAAuFD,EAAO9G,MAA9F,IAAsG8G,EAAOE,eCApGQ,MATf,WAIE,MAAkB,UAFCxG,IAAX3B,OAGA,cAAC,EAAD,IACA,cAAC,EAAD,KHJJoI,EACJxG,IAAMyG,cAA2BxI,EAAK,CAAElC,KAAM,MAC1C0G,EACJzC,IAAMyG,cAAwD,MAOzD,SAASC,EAAT,GAA4C,IAA3BlK,EAA0B,EAA1BA,QAASmK,EAAiB,EAAjBA,OAAiB,EACtB3G,IAAM4G,WAAWnH,EAAS,MAAM,kBAAMxB,EAAKzB,MADrB,mBACzCM,EADyC,KAClCyF,EADkC,KAGhDvC,IAAMI,WAAU,WACdmC,EAAS,CAAC5C,KAAM,OAAQnD,cACvB,CAACA,IAEJ,IAAMkJ,EAAY1F,IAAM2C,OAAsB,MAO9C,OANA3C,IAAMI,WAAU,WACTuG,GAAUjB,EAAUrE,UAAYvE,EAAOT,QAClB,OAAtBqJ,EAAUrE,SAAkBsF,EAAO7J,GACvC4I,EAAUrE,QAAUvE,EAAOT,SAC1B,CAACS,EAAO6J,IAGT,cAAClE,EAAgBoE,SAAjB,CAA0BC,MAAOvE,EAAjC,SACE,cAACiE,EAAaK,SAAd,CAAuBC,MAAOhK,EAA9B,SACE,cAAC,EAAD,QAMD,SAASiD,IACd,OAAOC,IAAMwC,WAAWgE,GAO1B,SAASvI,EAAKzB,GACZ,OAAOiD,EAAQ,KAAM,CAAEE,KAAM,OAAQnD,YIhBxBuK,MA3Bf,WAAmB,IAAD,EACY/G,IAAMC,SAA0B,IAD5C,mBACT+G,EADS,KACDC,EADC,OAEUjH,IAAMC,UAAU,GAF1B,mBAETzE,EAFS,KAEF0L,EAFE,KAIhBlH,IAAMI,WAAU,WACd+G,MAPgB,yFAQbC,MAAK,SAAA1H,GAAC,OAAIA,EAAE2H,UACZD,MAAK,YAAiB,IAAdJ,EAAa,EAAbA,OACPC,EAAUD,GACVE,EAASI,EAAKN,EAAO9L,cAExB,IAEH,IAAMyL,EAAS3G,IAAMuH,aAAY,SAAAC,MAE9B,IAEH,OAAe,IAAXhM,EAAqB,6CAGvB,qCACE,cAACkL,EAAD,CAAOlK,QAASwK,EAAOxL,GAAQmL,OAAQA,IACvC,wBAAQvB,QAAS,kBAAM8B,EAASI,EAAKN,EAAO9L,UAA5C,sBAQN,SAASoM,EAAK5J,GACZ,OAAO4G,KAAKC,MAAMD,KAAKmD,SAAW/J,G,If/BdgK,EAAaC,E,yBgBF7BC,EAAS,MACbC,EACAC,EAAQ,IAAkBC,QAC1BD,EAAQ,IAAkBC,QAC1BD,EAAQ,IAAkBC,QAC1BD,EAAQ,IAAkBC,QAC1BD,EAAQ,IAAkBC,QAC1BD,EAAQ,IAAkBC,QAC1BD,EAAQ,IAAkBC,SAGtBC,GhBTgBN,EgBSG,EhBTUC,EgBSPC,EAAO1M,OAAS,EhBTO,SAAC+M,GAClD,OAAIA,EAAMP,EAAYA,EAClBO,EAAMN,EAAYA,EACfM,IgB0EMC,MAlEf,WAAkB,IAAD,EAEblI,IAAMC,SAA+B,MAFxB,mBACRzD,EADQ,KACC2L,EADD,OAGWnI,IAAMC,SAAS,GAH1B,mBAGRmI,EAHQ,KAGDC,EAHC,OAImBrI,IAAMC,SAAgC,MAJzD,mBAIRI,EAJQ,KAIGiI,EAJH,KAKTC,EAAOvI,IAAM2C,OAA2B,IA0C9C,OAxCA3C,IAAMwI,iBAAgB,WACpB,IAAMC,EAAYC,QAAQC,IACxBJ,EAAKlH,QAAQ/F,KAAI,SAAAsN,GAEf,OADAA,EAAGC,OACI,IAAIH,SAAQ,SAAAI,GACjBF,EAAGG,UAAY,kBAAMD,EAAQF,WAInCzB,MAAM,0BAA0BC,KAAhC,uCAAqC,WAAM1H,GAAN,eAAAsJ,EAAA,sEAChBtJ,EAAE3D,OADc,cAC7BA,EAD6B,gBAE7B0M,EAF6B,OAGnCN,EAAW,CAAEpM,SAHsB,2CAArC,yDAKC,IA0BES,EAEH,qCACGoL,EAAOtM,KAAI,SAAC2N,EAAKzN,GAAN,OAAgByN,GAC1B,uBAEEzE,IAAK,SAAA9E,GAAC,OAAI6I,EAAKlH,QAAQ7F,EAAQ,GAAKkE,GACpCwJ,MAAO1N,IAAU4M,EACjBe,QAAQ,OACRC,MAAI,EALN,SAOE,wBAAQH,IAAKA,EAAKtJ,KAAK,eANlBnE,MAST,cAACkL,EAAD,CAAOlK,QAASA,EAASmK,OAtC7B,SAAgB7J,GAEd,GADIuD,GAAWE,aAAaF,GACxB9D,EAAaO,GAAjB,CACE,IAAMuM,EAAS3N,EAAIoB,EAAMa,MAAMH,KACzBhC,EAAQwM,EAAW1D,KAAKC,MAAM8E,EAAS,KAC7ChB,EAAS7M,OAHX,CAMA,IAAMgC,EAAuB,EdR1B,SAAiBV,GACtB,OAAO9B,EAAK8B,EAAMa,MAAMH,KcOV8L,CAAQxM,GACdtB,EAAQwM,EAAW1D,KAAKC,MAAM/G,EAAM,KAC1C6K,EAAS7M,GACT+M,EAAKlH,QAAQG,SAAQ,SAAA0C,GACnBA,EAAEqF,UAEJ,IAAMC,EAAKlJ,YAAW,WACpB+H,EAAS,GACTE,EAAKlH,QAAQG,SAAQ,SAAA0C,GACnBA,EAAEuF,QACFvF,EAAEwF,YAAc,OAEjB,KACHpB,EAAakB,UAGM,8CC3CRG,MAhBf,WACE,OACE,cAAC,IAAD,UACE,eAAC,IAAD,WACE,cAAC,IAAD,CAAOC,KAAK,UAAZ,SACE,cAAC,EAAD,MAEF,cAAC,IAAD,CAAOA,KAAK,SAAZ,SACE,cAAC,EAAD,MAEF,cAAC,IAAD,CAAUC,GAAG,kBCDNC,MAVf,WACE,OACE,qBAAK5J,UAAU,MAAf,SACE,wBAAQA,UAAU,aAAlB,SACE,cAAC,EAAD,SCKO6J,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqB7C,MAAK,YAAkD,IAA/C8C,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEF3I,SAAS4I,eAAe,SAM1BX,M","file":"static/js/main.d250b906.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/1.d7420ab5.wav\";","export default __webpack_public_path__ + \"static/media/2.9ee81949.wav\";","export default __webpack_public_path__ + \"static/media/3.c5b467d3.wav\";","export default __webpack_public_path__ + \"static/media/4.0f83ee86.wav\";","export default __webpack_public_path__ + \"static/media/5.1c9b447b.wav\";","export default __webpack_public_path__ + \"static/media/6.d6666621.wav\";","export default __webpack_public_path__ + \"static/media/7.a1d42fec.wav\";","interface ArrayLike {\n  [index: number]: any; \n  length: number\n}\n\nexport const clamp = (min: number, max: number) => (val: number) => {\n  if (val < min) return min;\n  if (val > max) return max;\n  return val;\n}\n\nexport const compose = (...fns: Function[]) => (arg: any, ...rest: any[]) => {\n  return fns.reduce((acc, fn) => fn(acc, ...rest), arg);\n}\n\nexport const last = (array: ArrayLike) => {\n  return array[array.length - 1];\n}\n\nexport const fillBetween = (\n  fn: Function\n) => (array: any[]) => {\n  const befores = array.slice(0, array.length - 1);\n  const afters = array.slice(1);\n\n  const res = tuplify(befores, afters)\n    .map(([before, after], index) => [before, fn(before, after, index)])\n    .flat();\n  res.push(last(array));\n  return res;\n}\n\nexport const tuplify = (firstItems: any[], ...arrays: any[][]) => {\n  return firstItems.map((first, index) => {\n    return [\n      first, \n      ...arrays.map(arr => arr[index])\n    ];\n  });\n}\n\nexport const memoize = (fn: Function, stackSize = 15) => {\n  const memory: Record<string, any> = {};\n  const keyStack: string[] = [];\n  return (...args: any[]) => {\n    const key = JSON.stringify(args);\n    if (!memory[key]) \n      memory[key] = fn(...args);\n    \n    // key cache\n    const keyIndex = keyStack.indexOf(key);\n    if (keyIndex !== -1) keyStack.splice(keyIndex, 1);\n    else if (keyStack.length >= stackSize) {\n      const oldKey = keyStack.shift();\n      delete memory[oldKey!];\n    }\n    keyStack.push(key);\n\n    return memory[key];\n  }\n}\n\nexport const spread = (obj: {[k:string]: any} | any[], path: (string | number)[], value: any): object => {\n  const [key, ...otherKeys] = path;\n  if (obj instanceof Array) {\n    return [\n      ...obj.slice(0, Number(key)),\n      otherKeys.length === 0\n        ? value\n        : spread(obj[Number(key)], otherKeys, value),\n      ...obj.slice(Number(key))\n    ]\n  }\n  return {\n    ...obj,\n    [key]: otherKeys.length === 0\n      ? value\n      : spread(obj[key + ''], otherKeys, value)\n  }\n}\n\n\nexport function avg(array: number[]) {\n  return array.reduce((s, v) => s + v, 0) / array.length;\n}","import { tuplify } from './std'\n\nexport const getWords = (text = '') => {\n  return text.split(' ').filter(w => w);\n}\n\nexport const getChars = (text = '') => {\n  return text.split('');\n}\n\nexport const getExtra = (text: string, typed = '') => {\n  if (typed.length > text.length)\n    return typed.substr(text.length);\n  return '';\n}\n\nexport const withExtra = (text: string, typed: string) => {\n  const wtext = getWords(text);\n  const wtyped = getWords(typed);\n  return tuplify(wtext, wtyped).map(([text, typed]) => {\n    return text + getExtra(text, typed);\n  }).join(' ');\n}\n\nexport const getWidth = (\n  text: string, \n  {fontFamily, fontSize}: {fontFamily: string, fontSize: number}\n) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context!.font = `${fontSize}px ${fontFamily}`;\n  return context!.measureText(text).width;\n}","import { last, tuplify } from \"./std\";\nimport { getChars, getExtra, getWords } from \"./text\";\n\nexport function didType(state: Typer.State, str: string) {\n  const { typed, content } = state;\n  const startIndex = content.text.indexOf(str);\n  if (startIndex === -1)\n    throw Error('string not found in text');\n  const endIndex = startIndex + str.length;\n  const substr = content.text.substr(0, endIndex);\n  const subWords = getWords(substr);\n  const typedWords = getWords(typed);\n  return typedWords.length >= subWords.length;\n}\n\nexport function wordStats(state: Typer.State, wordIndex: number) {\n  const { typed, content } = state;\n  const stats = { left: 0, correct: 0, extra: 0, wrong: 0 }\n  const word = getWords(content.text)[wordIndex];\n  const typedWord = getWords(typed)[wordIndex];\n  if (!typedWord) {\n    stats.left = word.length;\n    return stats;\n  }\n  tuplify(\n    getChars(word),\n    getChars(typedWord),\n  ).forEach(([char, typedChar]) => {\n    if (!typedChar) stats.left++;\n    else if (char === typedChar) stats.correct++;\n    else stats.wrong++;\n  });\n  const extraStr = getExtra(word, typedWord);\n  getChars(extraStr).forEach(() => {\n    stats.extra++;\n  });\n  return stats;\n}\n\nexport function lastWpm(state: Typer.State) {\n  return last(state.stats.wpm);\n}\n\nexport function isDoneTyping({ typed, content }: Typer.State) {\n  const typedWords = getWords(typed);\n  const allWords = getWords(content.text);\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}","import { isDoneTyping } from '../util/handlers';\nimport { compose, last } from '../util/std';\nimport { getWords } from '../util/text';\n\nconst typing: (\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) => Typer.State =  compose(\n  setTyped,\n  setCount,\n  setErrors,\n  setTemp,\n  setDone\n);\n\nexport default typing;\n\nfunction setTyped(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  let { typed } = state;\n  // dont add spaces together\n  if (char === ' ' && typed.endsWith(' ')) return state;\n  if (char === 'Backspace')\n    typed = typed.substr(0, typed.length - 1);\n  else typed = typed + char;\n  return { ...state, typed };\n}\n\nfunction setCount(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  if (['', 'Backspace'].includes(char)) \n    return state;\n  return {\n    ...state,\n    stats: { ...state.stats, count: state.stats.count + 1 }\n  };\n}\n\nfunction setErrors(\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) {\n  if (mistype(state, action))\n    return {\n      ...state,\n      stats: { ...state.stats, errors: state.stats.errors + 1 }\n    };\n  return state;\n}\n\nfunction setTemp(\n  state: Typer.State, \n  { time, char }: Typer.Actions.Typing\n) {\n  const { temp } = state;\n  if (temp.prevTime === 0) {\n    return {\n      ...state,\n      temp: {\n        delta: 0,\n        prevTime: time,\n        count: ['', 'Backspace'].includes(char) ? 0 : 1,\n        errors: mistype(state, { char }) ? 1 : 0\n      }\n    }\n  }\n  let delta = temp.delta + (time - temp.prevTime);\n  if (delta < 1000) {\n    return {\n      ...state,\n      temp: {\n        delta,\n        prevTime: time,\n        count: char === 'Backspace' ? temp.count : temp.count + 1,\n        errors: mistype(state, { char }) ? temp.errors + 1 : temp.errors\n      }\n    }\n  }\n  let newState = {...state};\n  while (delta > 1000) {\n    delta -= 1000;\n    newState = flushStats(newState, { time, char }, delta);\n    char = '';\n  }\n  return newState;\n}\n\nfunction setDone(state: Typer.State) {\n  if (isDoneTyping(state))\n    return {\n      ...state,\n      screen: 'stats'\n    }\n  return state;\n}\n\nfunction mistype(\n  state: Typer.State, \n  { char }: Pick<Typer.Actions.Typing, 'char'>\n) {\n  if (['', 'Backspace'].includes(char)) return false;\n\n  const { typed, content } = state;\n  const wordsTyped = getWords(typed);\n  const lastWord = last(wordsTyped);\n  const actualWord = getWords(content.text)[wordsTyped.length - 1];\n\n  // it'd be like that sometimes\n  if (!actualWord) return false;\n\n  if (typed.endsWith(' '))\n    return actualWord.length > lastWord.length;\n\n  const lastChar = lastWord[lastWord.length - 1];\n  const actualChar = actualWord[lastWord.length - 1];\n  return actualChar !== lastChar;\n}\n\nfunction flushStats(\n  state: Typer.State, \n  { time, char }: Pick<Typer.Actions.Typing, 'time' | 'char'>, \n  newDelta: number\n) {\n  const pm = 1 / 60 * 5;\n  const wpm = state.temp.count / pm;\n  return {\n    ...state,\n    stats: {\n      ...state.stats,\n      wpm: [...state.stats.wpm, wpm],\n      errs: [...state.stats.errs, state.temp.errors]\n    },\n    temp: {\n      delta: newDelta,\n      prevTime: time,\n      count: ['', 'Backspace'].includes(char) ? 0 : 1,\n      errors: mistype(state, { char }) ? 1 : 0\n    }\n  };\n}\n","import init from './init';\nimport typing from './typing';\nimport screen from './screen';\n\nconst ducers = {\n  init,\n  typing,\n  screen\n};\n\nexport default function reducer(\n  state: Typer.State | null, \n  action: Typer.Actions.Any) \n{\n  const r = ducers[action.type] as Reducer;\n  if (!r) return state;\n  return r(state, action);\n}\n\ntype Reducer = (state: Typer.State | null, action: Typer.Actions.Any) => Typer.State;","export default function init(\n  _state: Typer.State | null, \n  action: Typer.Actions.Init\n): Typer.State {\n  return {\n    content: action.content,\n    typed: '',\n    screen: 'typing',\n    stats: {\n      count: 0, \n      prevCount: 0, \n      wpm: [], \n      errors: 0,\n      errs: []\n    },\n    temp: {\n      prevTime: 0,\n      delta: 0,\n      errors: 0,\n      count: 0\n    },\n    config: {\n      fontFamily: 'monospace',\n      fontSize: 24,\n      lineHeight: 30,\n      width: 800, \n      colors: {\n        left: 'gray',\n        correct: 'white',\n        wrong: 'red',\n        extra: 'darkred',\n        caret: 'cyan'\n      }\n    }\n  }\n}","export default function screen(\n  state: Typer.State, \n  action: Typer.Actions.Screen\n): Typer.State {\n  return {\n    ...state,\n    screen: action.screen\n  }\n}","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  position: Typer.CaretPosition | null;\n  focused: boolean;\n}\n\nfunction Caret({ position, focused }: Props) {\n  const { config, typed } = useTyper();\n  const [className, setClassName] = React.useState('caret');\n\n  React.useEffect(() => {\n    setClassName('caret');\n    const timeoutId = setTimeout(() => {\n      setClassName('caret animated');\n    }, 500);\n    return () => clearTimeout(timeoutId);\n  }, [typed]);\n\n  if (!position) return null;\n\n  return (\n    <span \n      className={className}\n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        transform: `translate(${position.x - 8}px, ${position.y - 2}px)`,\n        color: config.colors.caret,\n        visibility: focused ? 'visible' : 'hidden'\n      }}\n    >|\n    </span>\n  );\n} \n\nexport default Caret;","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  text?: string;\n  typed?: string;\n}\n\nfunction Char({ text, typed }: Props) {\n  const { config } = useTyper();\n  const code = React.useMemo(() => {\n    if (!typed) return 'left';\n    if (!text) return 'extra';\n    if (typed === text) return 'correct';\n    return 'wrong';\n  }, [text, typed]);\n  const color = config.colors[code]\n  const str = text || typed;\n  const className = ['Char', code].join(' ')\n  return (\n    <span className={className} style={{color}}>{str}</span>\n  );\n}\n\nexport default Char;","import Char from \"./Char\";\nimport { useTyper } from \"./Typer\";\nimport { tuplify } from \"../util/std\";\nimport { getChars, getExtra, getWidth } from \"../util/text\";\nimport '../styles/Word.css';\n\ninterface Props {\n  text: string;\n  typed: string;\n  current: boolean;\n}\n\nfunction Word({ text, typed, current }: Props) {\n  const { config } = useTyper();\n  const _chars = tuplify(\n    getChars(text),\n    getChars(typed),\n  );\n  const extraStr = getExtra(text, typed);\n  getChars(extraStr).forEach(char => {\n    _chars.push([null, char]);\n  });\n  const redline = !current && typed && text !== typed;\n  const className = [\n    \"Word\", \n    redline && 'redline',\n    current && 'current'\n  ].filter(c => c).join(' ');\n  const space = getWidth(' ', config);\n  return (\n    <div \n      className={className} \n      style={{\n        marginRight: space, \n        borderBottomColor: redline ? config.colors.wrong : 'transparent'\n      }}\n    >\n      {_chars.map(([text, typed], index) => \n        <Char \n          key={index}\n          text={text}\n          typed={typed}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default Word;","import React from 'react';\nimport { tuplify } from '../util/std';\nimport { getWords } from '../util/text'\nimport { useTyper, useTyperDispatch } from './Typer'\nimport Caret from './Caret';\nimport Word from './Word';\nimport '../styles/TypingTest.css';\nimport { useCaret } from '../hooks/typing-test';\n\nfunction TypingTest() {\n  const { content, typed, config } = useTyper();\n  const dispatch = useTyperDispatch();\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [inputHasFocus, setInputFocus] = React.useState(false);\n  const [capslock, setCapslock] = React.useState(false);\n  const caretPosition = useCaret(typed, config);\n\n  React.useEffect(() => {\n    inputRef.current?.focus();\n  }, [content.text]);\n\n  const typedWords = getWords(typed)\n  const _words = tuplify(\n    getWords(content.text),\n    typedWords,\n    [null, ...typedWords],\n    typedWords.slice(1)\n  )\n\n  function onKeyPress(e: React.KeyboardEvent<HTMLInputElement>) {\n    capslockDetector(e);\n    const char = e.key;\n    if (char.length === 1 || char === 'Backspace') {\n      dispatch({ type: 'typing', char, time: Date.now() });\n      e.preventDefault();\n      return;\n    }\n  }\n\n  function capslockDetector(e: React.KeyboardEvent<HTMLInputElement>) {\n    setCapslock(e.getModifierState('CapsLock'));\n  }\n\n  function isCurrent(word: string, prev: string, next: string) {\n    if (!typed && !prev) return true;\n    if (typed.endsWith(' ')) return prev != null && word == null;\n    return word != null && next == null;\n  }\n\n  const offset = React.useMemo(() => {\n    if (!caretPosition) return 0;\n    const line = Math.floor(caretPosition.y / config.lineHeight);\n    if (line < 1) return 0\n    return (line - 1) * config.lineHeight;\n  }, [caretPosition, config]);\n\n  return (\n    <div className=\"TypingTest\" style={{\n      fontFamily: config.fontFamily,\n      fontSize: config.fontSize + 'px',\n      lineHeight: (config.lineHeight - 2) + 'px', // 2px border bottom\n    }}>\n      <input \n        ref={inputRef}\n        onKeyDown={onKeyPress}\n        onKeyUp={capslockDetector}\n        style={{height: 0, padding: 0, border: 0, position: \"absolute\"}}\n        onFocus={() => setInputFocus(true)}\n        onBlur={() => setInputFocus(false)}\n      />\n      <p style={{visibility: capslock ? \"visible\" : \"hidden\"}}>\n        CAPSLOCK IS ACTIVE\n      </p>\n      <div className=\"threeLines\" style={{height: config.lineHeight * 3 + 'px'}}>\n        <div \n          className=\"words\" \n          onClick={() => inputRef.current?.focus()}\n          style={{ maxWidth: config.width, transform: `translateY(${-offset}px)`}}\n        >\n          {_words.map(([text, typedWord, prevTyped, nextTyped], index) => \n            <Word\n              key={index}\n              text={text} \n              typed={typedWord}\n              current={isCurrent(typedWord, prevTyped, nextTyped)} \n            />\n          )}\n          <Caret position={caretPosition} focused={inputHasFocus} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default TypingTest;\n","import React from 'react';\nimport reducer from '../reducers';\nimport Screens from './Screens';\n\nexport * from '../util/handlers';\n\nconst StateContext = \n  React.createContext<Typer.State>(init({ text: '' })!);\nconst DispatchContext = \n  React.createContext<React.Dispatch<Typer.Actions.Any> | null>(null);\n\ninterface Props {\n  content: Typer.Content;\n  onType?(state: Typer.State): void;\n}\n\nexport function Typer({ content, onType }: Props) {\n  const [state, dispatch] = React.useReducer(reducer, null, () => init(content));\n\n  React.useEffect(() => {\n    dispatch({type: 'init', content });\n  }, [content]);\n\n  const prevTyped = React.useRef<string | null>(null);\n  React.useEffect(() => {\n    if (!onType || prevTyped.current === state!.typed) return;\n    if (prevTyped.current !== null) onType(state!);\n    prevTyped.current = state!.typed;\n  }, [state, onType]);\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state!}>\n        <Screens/>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n\nexport function useTyper() {\n  return React.useContext(StateContext);\n}\n\nexport function useTyperDispatch() {\n  return React.useContext(DispatchContext)!;\n}\n\nfunction init(content: Typer.Content) {\n  return reducer(null, { type: 'init', content });\n}","import React from 'react';\nimport { last } from '../util/std';\n\nexport function useCaret(typed: string, config: Typer.Config) {\n  const [pos, setPos] = React.useState<Typer.CaretPosition | null>(null);\n\n  React.useEffect(() => {\n    const wordEl = document.querySelector('.Word.current');\n    if (!wordEl) return;\n    const wordsEl = document.querySelector('.words')!;\n    const originRect = wordsEl.getBoundingClientRect();\n    const wrect = wordEl.getBoundingClientRect();\n    let charsTyped = wordEl.querySelectorAll('.Char:not(.left)');\n    if (charsTyped.length === 0) {\n      setPos({\n        x: wrect.left - originRect.left,\n        y: wrect.bottom - originRect.top - config.lineHeight\n      });\n      return;\n    }\n    const char = last(charsTyped);\n    const rect = char.getBoundingClientRect();\n    setPos({\n      x: rect.right - originRect.left,\n      y: wrect.bottom - originRect.top - config.lineHeight\n    });\n  }, [typed, config]);\n\n  return pos\n}","import { tuplify, avg } from '../util/std';\nimport { getChars, getWords, getExtra } from '../util/text';\nimport { useTyper } from './Typer';\n\nfunction Stats() {\n  const { stats, content, typed } = useTyper();\n  const acc = (1 - stats.errors / content.text.length) * 100\n  const counts = charCounts(content.text, typed);\n  return (\n    <>\n      <p>Avg: {avg(stats.wpm)} wpm</p>\n      <p>Time: {stats.wpm.length}s </p>\n      <p>Acc: {acc}%</p>\n      <p title=\"correct/incorrect/extra/missing\">Chars: {counts.correct}/{counts.incorrect}/{counts.extra}/{counts.missing}</p>\n    </>\n  )\n}\n\nexport default Stats;\n\nfunction charCounts(text: string, typed: string) {\n  let correct = 0, incorrect = 0, missing = 0, extras = 0\n  tuplify(\n    getWords(text),\n    getWords(typed)\n  ).forEach(([wtext, wtyped]) => {\n    tuplify(\n      getChars(wtext),\n      getChars(wtyped)\n    ).forEach(([chtext, chtyped]) => {\n      if (!chtyped) missing++;\n      else if (chtext === chtyped) correct++;\n      else incorrect++;\n    });\n    getChars(getExtra(wtext, wtyped)).forEach(() => extras++);\n  })\n  return {correct, incorrect, missing, extra: extras }\n}","import TypingTest from './TypingTest';\nimport Stats from './Stats';\nimport { useTyper } from './Typer';\n\nfunction Screens() {\n\n  const { screen } = useTyper();\n\n  return screen === 'stats' \n        ? <Stats />\n        : <TypingTest />;\n}\n\nexport default Screens;","import React from 'react';\nimport { Typer } from '../../components/Typer';\n\nconst MONKEY_JSON = 'https://raw.githubusercontent.com/Miodec/monkeytype/master/static/quotes/english.json';\n\nfunction Quotes() {\n  const [quotes, setQuotes] = React.useState<Typer.Content[]>([]);\n  const [index, setIndex] = React.useState(-1);\n\n  React.useEffect(() => {\n    fetch(MONKEY_JSON)\n      .then(r => r.json())\n      .then(({ quotes }) => {\n        setQuotes(quotes);\n        setIndex(rand(quotes.length));\n      });\n  }, [])\n\n  const onType = React.useCallback(t => {\n    // console.log(t);\n  }, []);\n\n  if (index === -1) return <div>Loading...</div>;\n\n  return (\n    <>\n      <Typer content={quotes[index]} onType={onType}/>\n      <button onClick={() => setIndex(rand(quotes.length))}>Next</button>\n    </>\n  );\n}\n\nexport default Quotes;\n\n\nfunction rand(count: number) {\n  return Math.floor(Math.random() * count);\n}","import React from 'react';\nimport { Typer, lastWpm, isDoneTyping } from \"../../components/Typer\";\nimport { avg, clamp } from '../../util/std';\nconst audios = [\n  undefined,\n  require('./audios/1.wav').default,\n  require('./audios/2.wav').default,\n  require('./audios/3.wav').default,\n  require('./audios/4.wav').default,\n  require('./audios/5.wav').default,\n  require('./audios/6.wav').default,\n  require('./audios/7.wav').default,\n]\n\nconst audioClamp = clamp(1, audios.length - 1);\n\nfunction Yoshi() {\n  const [content, setContent] = \n    React.useState<Typer.Content | null>(null);\n  const [track, setTrack] = React.useState(0);\n  const [timeoutId, setTimeoutId] = React.useState<NodeJS.Timeout | null>(null)\n  const refs = React.useRef<HTMLAudioElement[]>([]);\n\n  React.useLayoutEffect(() => {\n    const audioProm = Promise.all(\n      refs.current.map(el => {\n        el.load();\n        return new Promise(resolve => {\n          el.oncanplay = () => resolve(el);\n        })\n      })\n    );\n    fetch('/nancio-type/yoshi.txt').then(async r => {\n      const text = await r.text();\n      await audioProm;\n      setContent({ text });\n    });\n  }, []);\n\n  function onType(state: Typer.State) {\n    if (timeoutId) clearTimeout(timeoutId);\n    if (isDoneTyping(state)) {\n      const avgWpm = avg(state.stats.wpm);\n      const index = audioClamp(Math.floor(avgWpm / 15));\n      setTrack(index);\n      return;\n    }\n    const wpm = lastWpm(state) | 0;\n    const index = audioClamp(Math.floor(wpm / 15));\n    setTrack(index);\n    refs.current.forEach(e => {\n      e.play();\n    });\n    const id = setTimeout(() => {\n      setTrack(0);\n      refs.current.forEach(e => {\n        e.pause();\n        e.currentTime = 0;\n      })\n    }, 1000);\n    setTimeoutId(id);\n  }\n\n  if (!content) return <div>Loading...</div>;\n  return (\n    <>\n      {audios.map((src, index) => src &&\n        <audio \n          key={index} \n          ref={r => refs.current[index - 1] = r!}\n          muted={index !== track}\n          preload=\"auto\"\n          loop \n        >\n          <source src={src} type=\"audio/wav\"/>\n        </audio>\n      ) }\n      <Typer content={content} onType={onType}/>\n    </>\n  );\n}\n\nexport default Yoshi;","import { HashRouter, Switch, Route, Redirect } from 'react-router-dom';\nimport Quotes from './quotes/Quotes';\nimport Yoshi from './yoshi/Yoshi';\n\nfunction Router() {\n  return (\n    <HashRouter>\n      <Switch>\n        <Route path=\"/quotes\">\n          <Quotes/>\n        </Route>\n        <Route path=\"/yoshi\">\n          <Yoshi/>\n        </Route>\n        <Redirect to=\"/quotes\"/>\n      </Switch>\n    </HashRouter>\n  );\n}\n\nexport default Router;","import './App.css';\nimport Router from './pages';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Router/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
{"version":3,"sources":["util/std.js","util/text.js","reducers/typing.js","reducers/index.js","reducers/init.js","reducers/interval.js","reducers/screen.js","components/StateProvider.js","components/Caret.js","components/Char.js","components/Word.js","components/TypingTest.js","hooks/typing-test.js","components/Stats.js","components/Typer.js","App.js","reportWebVitals.js","index.js"],"names":["last","array","length","tuplify","firstItems","arrays","map","first","index","arr","words","text","split","filter","w","chars","extra","typed","substr","mistype","state","char","includes","content","wordsTyped","lastWord","actualWord","endsWith","lastChar","flushStats","newDelta","time","wpm","temp","count","stats","errs","errors","delta","prevTime","ducers","init","_state","screen","prevCount","config","fontFamily","fontSize","lineHeight","width","colors","left","correct","wrong","caret","typing","fns","arg","rest","reduce","acc","fn","compose","action","newState","typedWords","allWords","lastTyped","pop","doneTyping","interval","k","reducer","r","type","StateContext","React","createContext","DispatchContext","TyperProvider","firstContent","children","useReducer","dispatch","Provider","value","useTyper","useContext","Caret","position","focused","useState","className","setClassName","useEffect","timeoutId","setTimeout","clearTimeout","style","top","transform","x","y","color","visibility","Char","code","useMemo","str","join","Word","current","_chars","extraStr","forEach","push","c","space","context","document","createElement","getContext","font","measureText","getTextWidth","marginRight","TypingTest","onType","inputRef","useRef","inputHasFocus","setInputFocus","capslock","setCapslock","caretPosition","pos","setPos","wordEl","querySelector","originRect","getBoundingClientRect","wrect","charsTyped","querySelectorAll","rect","right","bottom","useCaret","focus","_words","slice","capslockDetector","e","getModifierState","offset","line","Math","floor","height","ref","onKeyDown","preventDefault","onKeyUp","padding","border","onFocus","onBlur","onClick","word","prev","next","typedWord","prevTyped","nextTyped","Stats","counts","incorrect","missing","extras","wtext","wtyped","chtext","chtyped","charCounts","s","v","title","Typer","nextContent","onNext","key","Date","now","quotes","require","App","randomQuote","random","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.57c9a091.chunk.js","sourcesContent":["export const clamp = (min, max) => val => {\n  if (val < min) return min;\n  if (val > max) return max;\n  return val;\n}\n\nexport const compose = (...fns) => (arg, ...rest) => {\n  return fns.reduce((acc, fn) => fn(acc, ...rest), arg);\n}\n\nexport const last = array => {\n  return array[array.length - 1];\n}\n\nexport const fillBetween = fn => array => {\n  const befores = array.slice(0, array.length - 1);\n  const afters = array.slice(1);\n\n  const res = tuplify(befores, afters)\n    .map(([before, after], index) => [before, fn(before, after, index)])\n    .flat();\n  res.push(last(array));\n  return res;\n}\n\nexport const tuplify = (firstItems, ...arrays) => {\n  return firstItems.map((first, index) => {\n    return [\n      first, \n      ...arrays.map(arr => arr[index])\n    ];\n  });\n}\n\nexport const memoize = (fn, stackSize = 15) => {\n  const memory = {};\n  const keyStack = [];\n  return (...args) => {\n    const key = JSON.stringify(args);\n    if (!memory[key]) \n      memory[key] = fn(...args);\n    \n    // key cache\n    const keyIndex = keyStack.indexOf(key);\n    if (keyIndex !== -1) keyStack.splice(keyIndex, 1);\n    else if (keyStack.length >= stackSize) {\n      const oldKey = keyStack.shift();\n      delete memory[oldKey];\n    }\n    keyStack.push(key);\n\n    return memory[key];\n  }\n}\n\nexport const spread = (obj, path, value) => {\n  const [key, ...otherKeys] = path;\n  if (typeof key === 'number') {\n    return [\n      ...obj.slice(0, key),\n      otherKeys.length === 0\n        ? value\n        : spread(obj[key], otherKeys.join('.'), value),\n      ...obj.slice(key)\n    ]\n  }\n  return {\n    ...obj,\n    [key]: otherKeys.length === 0\n      ? value\n      : spread(obj[key], otherKeys.join('.'), value)\n  }\n}","import { last, tuplify } from './std'\n\nexport const words = (text = '') => {\n  return text.split(' ').filter(w => w);\n}\n\nexport const chars = (text = '') => {\n  return text.split('');\n}\n\nexport const extra = text => (typed = '') => {\n  if (typed.length > text.length)\n    return typed.substr(text.length);\n  return '';\n}\n\nexport const withExtra = (text, typed) => {\n  const wtext = words(text);\n  const wtyped = words(typed);\n  return tuplify(wtext, wtyped).map(([text, typed]) => {\n    return text + extra(text)(typed);\n  }).join(' ');\n}\n\nexport const getTextWidth = (text, {fontFamily, fontSize}) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context.font = `${fontSize}px ${fontFamily}`;\n  return context.measureText(text).width;\n}","import { compose, last } from '../util/std';\nimport { words } from '../util/text';\n\nexport default compose(\n  setTyped,\n  setCount,\n  setErrors,\n  setTemp,\n  setDone\n)\n\nfunction setTyped(state, { char }) {\n  let { typed } = state;\n  // dont add spaces together\n  if (char === ' ' && typed.endsWith(' ')) return state;\n  if (char === 'Backspace')\n    typed = typed.substr(0, typed.length - 1);\n  else typed = typed + char;\n  return { ...state, typed };\n}\n\nfunction setCount(state, { char }) {\n  if (['', 'Backspace'].includes(char)) \n    return state;\n  return {\n    ...state,\n    stats: { ...state.stats, count: state.stats.count + 1 }\n  };\n}\n\nfunction setErrors(state, action) {\n  if (mistype(state, action))\n    return {\n      ...state,\n      stats: { ...state.stats, errors: state.stats.errors + 1 }\n    };\n  return state;\n}\n\nfunction setTemp(state, { time, char }) {\n  const { temp } = state;\n  if (temp.prevTime === 0) {\n    return {\n      ...state,\n      temp: {\n        delta: 0,\n        prevTime: time,\n        count: ['', 'Backspace'].includes(char) ? 0 : 1,\n        errors: mistype(state, { char }) ? 1 : 0\n      }\n    }\n  }\n  let delta = temp.delta + (time - temp.prevTime);\n  if (delta < 1000) {\n    return {\n      ...state,\n      temp: {\n        delta,\n        prevTime: time,\n        count: char === 'Backspace' ? temp.count : temp.count + 1,\n        errors: mistype(state, { char }) ? temp.errors + 1 : temp.errors\n      }\n    }\n  }\n  let newState = {...state};\n  while (delta > 1000) {\n    delta -= 1000;\n    newState = flushStats(newState, { time, char }, delta);\n    char = '';\n  }\n  return newState;\n}\n\nfunction setDone(state) {\n  if (doneTyping(state))\n    return {\n      ...state,\n      screen: 'stats'\n    }\n  return state;\n}\n\nfunction mistype(state, { char }) {\n  if (['', 'Backspace'].includes(char)) return false;\n\n  const { typed, content } = state;\n  const wordsTyped = words(typed);\n  const lastWord = last(wordsTyped);\n  const actualWord = words(content.text)[wordsTyped.length - 1];\n\n  // it'd be like that sometimes\n  if (!actualWord) return false;\n\n  if (typed.endsWith(' '))\n    return actualWord.length > lastWord.length;\n\n  const lastChar = lastWord[lastWord.length - 1];\n  const actualChar = actualWord[lastWord.length - 1];\n  return actualChar !== lastChar;\n}\n\nfunction flushStats(state, { time, char }, newDelta) {\n  const pm = 1 / 60 * 5;\n  const wpm = state.temp.count / pm;\n  if (wpm > 200) debugger;\n  return {\n    ...state,\n    stats: {\n      ...state.stats,\n      wpm: [...state.stats.wpm, wpm],\n      errs: [...state.stats.errs, state.temp.errors]\n    },\n    temp: {\n      delta: newDelta,\n      prevTime: time,\n      count: ['', 'Backspace'].includes(char) ? 0 : 1,\n      errors: mistype(state, { char }) ? 1 : 0\n    }\n  };\n}\n\nfunction doneTyping({ typed, content }) {\n  const typedWords = words(typed);\n  const allWords = words(content.text);\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}","import init from './init';\nimport typing from './typing';\nimport interval from './interval';\nimport screen from './screen';\n\nconst ducers = {\n  init,\n  typing,\n  interval,\n  screen\n}\nexport default function reducer(state, action) {\n  const r = ducers[action.type];\n  if (!r) return state;\n  return r(state, action);\n}","export default function init(_state, {content = {text: ''}}) {\n  return {\n    content,\n    typed: '',\n    screen: 'typing',\n    stats: {\n      count: 0, \n      prevCount: 0, \n      wpm: [], \n      errors: 0,\n      errs: []\n    },\n    temp: {\n      prevTime: 0,\n      delta: 0,\n      errors: 0,\n      count: 0\n    },\n    config: {\n      fontFamily: 'monospace',\n      fontSize: 24,\n      lineHeight: 30,\n      width: 800, \n      colors: {\n        left: 'gray',\n        correct: 'white',\n        wrong: 'red',\n        extra: 'darkred',\n        caret: 'cyan'\n      }\n    }\n  }\n}","export default function interval(state, action) {\n  if (state.stats.count === 0) return state;\n  const k = action.delta / 60 * 5; //transform to wpm\n  return {\n    ...state,\n    stats: {\n      ...state.stats,\n      prevCount: state.stats.count,\n      wpm: [\n        ...state.stats.wpm,\n        (state.stats.count - state.stats.prevCount) / k\n      ]\n    }\n  }\n}","export default function screen(state, action) {\n  return {\n    ...state,\n    screen: action.screen\n  }\n}","import React from 'react';\nimport reducer from '../reducers';\n\nconst StateContext = React.createContext();\nconst DispatchContext = React.createContext();\n\nexport function TyperProvider({ firstContent, children }) {\n  const [state, dispatch] = React.useReducer(reducer, null, () => init(firstContent()));\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state}>\n        {children}\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n\nexport function useTyper() {\n  return React.useContext(StateContext);\n}\n\nexport function useTyperDispatch() {\n  return React.useContext(DispatchContext);\n}\n\nfunction init(content) {\n  return reducer(null, { type: 'init', content });\n}","import React from 'react';\nimport { useTyper } from \"./StateProvider\";\n\nfunction Caret({ position, focused }) {\n  const { config, typed } = useTyper();\n  const [className, setClassName] = React.useState('caret');\n\n  React.useEffect(() => {\n    setClassName('caret');\n    const timeoutId = setTimeout(() => {\n      setClassName('caret animated');\n    }, 500);\n    return () => clearTimeout(timeoutId);\n  }, [typed]);\n\n  if (!position) return null;\n\n  return (\n    <span \n      className={className}\n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        transform: `translate(${position.x - 8}px, ${position.y - 2}px)`,\n        color: config.colors.caret,\n        visibility: focused ? 'visible' : 'hidden'\n      }}\n    >|\n    </span>\n  );\n} \n\nexport default Caret;","import React from 'react';\nimport { useTyper } from \"./StateProvider\";\n\nfunction Char({ text, typed }) {\n  const { config } = useTyper();\n  const code = React.useMemo(() => {\n    if (!typed) return 'left';\n    if (!text) return 'extra';\n    if (typed === text) return 'correct';\n    return 'wrong';\n  }, [text, typed]);\n  const color = config.colors[code]\n  const str = text || typed;\n  const className = ['Char', code].join(' ')\n  return (\n    <span className={className} style={{color}}>{str}</span>\n  );\n}\n\nexport default Char;","import Char from \"./Char\";\nimport { useTyper } from \"./StateProvider\";\nimport { tuplify } from \"../util/std\";\nimport { chars, extra, getTextWidth } from \"../util/text\";\nimport '../styles/Word.css';\n\nfunction Word({ text, typed, current }) {\n  const { config } = useTyper();\n  const _chars = tuplify(\n    chars(text),\n    chars(typed),\n  );\n  const extraStr = extra(text)(typed);\n  chars(extraStr).forEach(char => {\n    _chars.push([null, char]);\n  });\n  const redline = !current && typed && text !== typed;\n  const className = [\n    \"Word\", \n    redline && 'redline',\n    current && 'current'\n  ].filter(c => c).join(' ');\n  const space = getTextWidth(' ', config);\n  return (\n    <div className={className} style={{marginRight: space}}>\n      {_chars.map(([text, typed], index) => \n        <Char \n          key={index}\n          text={text}\n          typed={typed}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default Word;","import React from 'react';\nimport { tuplify } from '../util/std';\nimport { words } from '../util/text'\nimport { useTyper } from './StateProvider'\nimport Caret from './Caret';\nimport Word from './Word';\nimport '../styles/TypingTest.css';\nimport { useCaret } from '../hooks/typing-test';\n\nfunction TypingTest({ onType }) {\n  const { content, typed, config } = useTyper();\n\n  const inputRef = React.useRef();\n  const [inputHasFocus, setInputFocus] = React.useState(false);\n  const [capslock, setCapslock] = React.useState(false);\n  const caretPosition = useCaret(typed, config);\n\n  React.useEffect(() => {\n    inputRef.current.focus();\n  }, [content.text]);\n\n  const typedWords = words(typed)\n  const _words = tuplify(\n    words(content.text),\n    typedWords,\n    [null, ...typedWords],\n    typedWords.slice(1)\n  )\n\n  function onKeyPress(e) {\n    const prevent = onType(e);\n    if (prevent) e.preventDefault();\n    capslockDetector(e);\n  }\n\n  function capslockDetector(e) {\n    setCapslock(e.getModifierState('CapsLock'));\n  }\n\n  function isCurrent(word, prev, next) {\n    if (!typed && !prev) return true;\n    if (typed.endsWith(' ')) return prev && !word;\n    return word && !next;\n  }\n\n  const offset = React.useMemo(() => {\n    if (!caretPosition) return 0;\n    const line = Math.floor(caretPosition.y / config.lineHeight);\n    if (line < 1) return 0\n    return (line - 1) * config.lineHeight;\n  }, [caretPosition, config]);\n\n  return (\n    <div className=\"TypingTest\" style={{\n      fontFamily: config.fontFamily,\n      fontSize: config.fontSize + 'px',\n      lineHeight: (config.lineHeight - 2) + 'px', // 2px border bottom\n      height: config.lineHeight * 3 + 'px'\n    }}>\n      <input \n        ref={inputRef}\n        onKeyDown={onKeyPress}\n        onKeyUp={capslockDetector}\n        style={{height: 0, padding: 0, border: 0, position: \"absolute\"}}\n        onFocus={() => setInputFocus(true)}\n        onBlur={() => setInputFocus(false)}\n      />\n      {capslock && <p>CAPSLOCK IS ACTIVE</p>}\n      <div \n        className=\"words\" \n        onClick={() => inputRef.current.focus()}\n        style={{ width: config.width, transform: `translateY(${-offset}px)`}}\n      >\n        {_words.map(([text, typedWord, prevTyped, nextTyped], index) => \n          <Word\n            key={index}\n            text={text} \n            typed={typedWord}\n            current={isCurrent(typedWord, prevTyped, nextTyped)} \n          />\n        )}\n        <Caret position={caretPosition} focused={inputHasFocus} />\n      </div>\n    </div>\n  )\n}\n\nexport default TypingTest;\n","import React from 'react';\nimport { last } from '../util/std';\n\nexport function useCaret(typed, config) {\n  const [pos, setPos] = React.useState(null);\n\n  React.useEffect(() => {\n    const wordEl = document.querySelector('.Word.current');\n    if (!wordEl) return;\n    const wordsEl = document.querySelector('.words');\n    const originRect = wordsEl.getBoundingClientRect();\n    const wrect = wordEl.getBoundingClientRect();\n    let charsTyped = wordEl.querySelectorAll('.Char:not(.left)');\n    if (charsTyped.length === 0) {\n      setPos({\n        x: wrect.left - originRect.left,\n        y: wrect.bottom - originRect.top - config.lineHeight\n      });\n      return;\n    }\n    const char = last(charsTyped);\n    const rect = char.getBoundingClientRect();\n    setPos({\n      x: rect.right - originRect.left,\n      y: wrect.bottom - originRect.top - config.lineHeight\n    });\n  }, [typed, config]);\n\n  return pos\n}","import React from 'react';\nimport { tuplify } from '../util/std';\nimport { chars, words, extra } from '../util/text';\n\n\nfunction Stats({ state }) {\n  const { stats, content, typed } = state;\n  const acc = (1 - stats.errors / content.text.length) * 100\n  const counts = charCounts(content.text, typed);\n  return (\n    <>\n      <p>Avg: {avg(stats.wpm)} wpm</p>\n      <p>Time: {stats.wpm.length}s </p>\n      <p>Acc: {acc}%</p>\n      <p title=\"correct/incorrect/extra/missing\">Chars: {counts.correct}/{counts.incorrect}/{counts.extra}/{counts.missing}</p>\n    </>\n  )\n}\n\nexport default Stats;\n\nfunction avg(array) {\n  return array.reduce((s, v) => s + v, 0) / array.length;\n}\n\nfunction charCounts(text, typed) {\n  let correct = 0, incorrect = 0, missing = 0, extras = 0\n  tuplify(\n    words(text),\n    words(typed)\n  ).forEach(([wtext, wtyped]) => {\n    tuplify(\n      chars(wtext),\n      chars(wtyped)\n    ).forEach(([chtext, chtyped]) => {\n      if (!chtyped) missing++;\n      else if (chtext === chtyped) correct++;\n      else incorrect++;\n    });\n    chars(extra(wtext)(wtyped)).forEach(() => extras++);\n  })\n  return {correct, incorrect, missing, extra: extras }\n}","import React from 'react';\nimport TypingTest from './TypingTest';\nimport Stats from './Stats';\nimport { useTyper, useTyperDispatch } from './StateProvider';\n\nfunction Typer({ nextContent }) {\n\n  const [state, dispatch] = [useTyper(), useTyperDispatch()];\n\n  React.useEffect(() => {\n    if (state.screen === 'typing' &&  doneTyping(state)) {\n      dispatch({ type: 'screen', screen: 'stats' });\n    }\n  }, [state, dispatch]);\n\n  function onType(e) {\n    const char = e.key;\n    if (char.length === 1 || char === 'Backspace') {\n      dispatch({ type: 'typing', char, time: Date.now() });\n      return true;\n    }\n    return false;\n  }\n\n  function onNext() {\n    dispatch({ type: 'init', content: nextContent() })\n  }\n\n  return (\n    <>\n      {state.screen === 'stats' \n        ? <Stats state={state} onNext={onNext}/>\n        : <TypingTest\n            onType={onType}\n          />\n      }\n      <button onClick={onNext}>Next</button>\n    </>\n  );\n}\n\nexport default Typer;\n\nfunction doneTyping({typed, content}) {\n  const typedWords = typed.split(' ').filter(w => w);\n  const allWords = content.text.split(' ');\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}","import React from 'react';\nimport './App.css';\nimport Typer from './components/Typer';\nimport { TyperProvider } from './components/StateProvider';\nconst { quotes } = require('./quotes.json')\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <TyperProvider firstContent={randomQuote}>\n          <Typer nextContent={randomQuote}/>\n        </TyperProvider>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n\n\nfunction randomQuote() {\n  const index = Math.floor(Math.random() * quotes.length);\n  return quotes[index]\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
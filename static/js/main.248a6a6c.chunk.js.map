{"version":3,"sources":["pages/yoshi/audios/1.wav","pages/yoshi/audios/2.wav","pages/yoshi/audios/3.wav","pages/yoshi/audios/4.wav","pages/yoshi/audios/5.wav","pages/yoshi/audios/6.wav","pages/yoshi/audios/7.wav","util/std.ts","util/text.ts","util/handlers.ts","reducers/index.ts","reducers/init.ts","reducers/typing.ts","reducers/screen.ts","components/Caret.tsx","components/Char.tsx","components/Word.tsx","components/TypingTest.tsx","components/Typer.tsx","hooks/typing-test.ts","components/Stats.tsx","components/Screens.tsx","pages/quotes/Quotes.tsx","pages/yoshi/Yoshi.tsx","pages/index.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["last","array","length","tuplify","firstItems","arrays","map","first","index","arr","IGNORED_CHARACTERS","getWords","text","split","filter","w","getChars","getExtra","typed","substr","isDoneTyping","content","typedWords","allWords","endsWith","pop","netWpm","state","rawWpm","errors","forEach","typedWord","word","typedChar","unfixedErrors","typedMilis","timeline","i","includes","char","typedCount","timestamp","timeSlice","from","to","overtime","start","findIndex","end","slice","ducers","init","_state","action","screen","temp","prevTime","delta","count","config","fontFamily","fontSize","lineHeight","width","colors","left","correct","wrong","extra","caret","typing","fns","arg","rest","reduce","acc","fn","compose","time","reducer","r","type","Caret","position","focused","useTyper","React","useState","className","setClassName","useEffect","timeoutId","setTimeout","clearTimeout","style","top","transform","x","y","color","visibility","Char","code","useMemo","str","join","Word","current","_chars","extraStr","push","redline","c","space","context","document","createElement","getContext","font","measureText","getWidth","marginRight","borderBottomColor","TypingTest","dispatch","useContext","DispatchContext","inputRef","useRef","inputHasFocus","setInputFocus","capslock","setCapslock","caretPosition","pos","setPos","wordEl","querySelector","originRect","getBoundingClientRect","wrect","charsTyped","querySelectorAll","rect","right","bottom","useCaret","focus","_words","capslockDetector","e","getModifierState","offset","line","Math","floor","threeLinesHeight","ref","onKeyDown","key","Date","now","preventDefault","onKeyUp","height","padding","border","onFocus","onBlur","onClick","maxWidth","prev","next","prevTyped","nextTyped","Stats","counts","incorrect","missing","extras","wtext","wtyped","chtext","chtyped","charCounts","startTime","duration","chartData","data","Array","round","_","second","wpm","wpmPoint","raw","slicePoint","errorPoint","total","sum","d","ComposedChart","Line","yAxisId","dataKey","stroke","fill","Scatter","CartesianGrid","strokeDasharray","XAxis","tickCount","domain","allowDecimals","YAxis","orientation","Tooltip","st","errs","item","Number","wordsTyped","lastWord","actualWord","lastChar","mistypedLast","Screens","StateContext","createContext","Typer","onType","useReducer","Provider","value","Quotes","quotes","setQuotes","setIndex","fetch","process","then","json","rand","useCallback","t","random","min","max","audios","undefined","require","default","audioClamp","val","Yoshi","setContent","track","setTrack","setTimeoutId","refs","useLayoutEffect","audioProm","Promise","all","el","load","resolve","oncanplay","a","src","muted","preload","loop","net","endTime","lastWpm","play","id","pause","currentTime","Router","path","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.248a6a6c.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/1.d7420ab5.wav\";","export default __webpack_public_path__ + \"static/media/2.9ee81949.wav\";","export default __webpack_public_path__ + \"static/media/3.c5b467d3.wav\";","export default __webpack_public_path__ + \"static/media/4.0f83ee86.wav\";","export default __webpack_public_path__ + \"static/media/5.1c9b447b.wav\";","export default __webpack_public_path__ + \"static/media/6.d6666621.wav\";","export default __webpack_public_path__ + \"static/media/7.a1d42fec.wav\";","interface ArrayLike {\n  [index: number]: any; \n  length: number\n}\n\nexport const clamp = (min: number, max: number) => (val: number) => {\n  if (val < min) return min;\n  if (val > max) return max;\n  return val;\n}\n\nexport const compose = (...fns: Function[]) => (arg: any, ...rest: any[]) => {\n  return fns.reduce((acc, fn) => fn(acc, ...rest), arg);\n}\n\nexport const last = (array: ArrayLike) => {\n  return array[array.length - 1];\n}\n\nexport const fillBetween = (\n  fn: Function\n) => (array: any[]) => {\n  const befores = array.slice(0, array.length - 1);\n  const afters = array.slice(1);\n\n  const res = tuplify(befores, afters)\n    .map(([before, after], index) => [before, fn(before, after, index)])\n    .flat();\n  res.push(last(array));\n  return res;\n}\n\nexport const tuplify = (firstItems: any[], ...arrays: any[][]) => {\n  return firstItems.map((first, index) => {\n    return [\n      first, \n      ...arrays.map(arr => arr[index])\n    ];\n  });\n}\n\nexport const memoize = (fn: Function, stackSize = 15) => {\n  const memory: Record<string, any> = {};\n  const keyStack: string[] = [];\n  return (...args: any[]) => {\n    const key = JSON.stringify(args);\n    if (!memory[key]) \n      memory[key] = fn(...args);\n    \n    // key cache\n    const keyIndex = keyStack.indexOf(key);\n    if (keyIndex !== -1) keyStack.splice(keyIndex, 1);\n    else if (keyStack.length >= stackSize) {\n      const oldKey = keyStack.shift();\n      delete memory[oldKey!];\n    }\n    keyStack.push(key);\n\n    return memory[key];\n  }\n}\n\nexport const spread = (obj: {[k:string]: any} | any[], path: (string | number)[], value: any): object => {\n  const [key, ...otherKeys] = path;\n  if (obj instanceof Array) {\n    return [\n      ...obj.slice(0, Number(key)),\n      otherKeys.length === 0\n        ? value\n        : spread(obj[Number(key)], otherKeys, value),\n      ...obj.slice(Number(key))\n    ]\n  }\n  return {\n    ...obj,\n    [key]: otherKeys.length === 0\n      ? value\n      : spread(obj[key + ''], otherKeys, value)\n  }\n}\n\nexport function sum(array: number[]) {\n  return array.reduce((s, v) => s + v, 0);\n}\n\nexport function avg(array: number[]) {\n  return sum(array) / array.length;\n}","import { tuplify } from './std'\n\nexport const IGNORED_CHARACTERS = ['', 'Backspace'];\n\nexport const getWords = (text = '') => {\n  return text.split(' ').filter(w => w);\n}\n\nexport const getChars = (text = '') => {\n  return text.split('');\n}\n\nexport const getExtra = (text: string, typed = '') => {\n  if (typed.length > text.length)\n    return typed.substr(text.length);\n  return '';\n}\n\nexport const withExtra = (text: string, typed: string) => {\n  const wtext = getWords(text);\n  const wtyped = getWords(typed);\n  return tuplify(wtext, wtyped).map(([text, typed]) => {\n    return text + getExtra(text, typed);\n  }).join(' ');\n}\n\nexport const getWidth = (\n  text: string, \n  {fontFamily, fontSize}: {fontFamily: string, fontSize: number}\n) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context!.font = `${fontSize}px ${fontFamily}`;\n  return context!.measureText(text).width;\n}","import { last, tuplify } from \"./std\";\nimport { getChars, getExtra, getWords, IGNORED_CHARACTERS } from \"./text\";\n\nexport function didType(state: Typer.State, str: string) {\n  const { typed, content } = state;\n  const startIndex = content.text.indexOf(str);\n  if (startIndex === -1)\n    throw Error('string not found in text');\n  const endIndex = startIndex + str.length;\n  const substr = content.text.substr(0, endIndex);\n  const subWords = getWords(substr);\n  const typedWords = getWords(typed);\n  return typedWords.length >= subWords.length;\n}\n\nexport function wordStats(state: Typer.State, wordIndex: number) {\n  const { typed, content } = state;\n  const stats = { left: 0, correct: 0, extra: 0, wrong: 0 }\n  const word = getWords(content.text)[wordIndex];\n  const typedWord = getWords(typed)[wordIndex];\n  if (!typedWord) {\n    stats.left = word.length;\n    return stats;\n  }\n  tuplify(\n    getChars(word),\n    getChars(typedWord),\n  ).forEach(([char, typedChar]) => {\n    if (!typedChar) stats.left++;\n    else if (char === typedChar) stats.correct++;\n    else stats.wrong++;\n  });\n  const extraStr = getExtra(word, typedWord);\n  getChars(extraStr).forEach(() => {\n    stats.extra++;\n  });\n  return stats;\n}\n\nexport function lastWpm(state: Typer.State) {\n  if (state.timeline.length === 0) return 0;\n  const endTime = last(state.timeline).timestamp;\n  let slice = timeSlice(\n    state, \n    endTime - 5000,\n    endTime + 1000,\n    false\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice).typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return rawWpm(st);\n}\n\nexport function isDoneTyping({ typed, content }: Typer.State) {\n  const typedWords = getWords(typed);\n  const allWords = getWords(content.text);\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}\n\nexport function netWpm(state: Pick<Typer.State, 'timeline' | 'content' | 'typed'>) {\n  return rawWpm(state) - unfixedErrors(state) / typedMilis(state) * 1000 * 60;\n}\n\nexport function rawWpm(state: Pick<Typer.State, 'timeline'>) {\n  return typedCount(state) / typedMilis(state) * 1000 * 60 / 5;\n}\n\nexport function typedCount(state: Pick<Typer.State, 'timeline'>) {\n  return state.timeline\n    .filter(i => !IGNORED_CHARACTERS.includes(i.char))\n    .length;\n}\n\nexport function typedMilis(state: Pick<Typer.State, 'timeline'>) {\n  return last(state.timeline).timestamp - state.timeline[0].timestamp;\n}\n\nexport function unfixedErrors(state: Pick<Typer.State, 'typed' | 'content'>) {\n  let errors = 0;\n  const typedWords = getWords(state.typed);\n  tuplify(\n    typedWords,\n    getWords(state.content.text),\n  ).forEach(([typedWord, word], index) => {\n    if (index < typedWords.length -1 && word.length > typedWord.length) {\n      errors++; // all missings as one error\n    }\n    tuplify(\n      getChars(typedWord),\n      getChars(word),\n    ).forEach(([typedChar, char]) => {\n      if (char === typedChar) return;\n      errors++; // extras and incorrects\n    });\n  });\n  return errors;\n}\n\nexport function groupTimeline(\n  state: Typer.State, \n  groupMilis: number = 1000\n): Typer.TimelineItem[][] {\n  let groups: Typer.TimelineItem[][] = [];\n  let [firstItem, ...rest] = state.timeline;\n  let prevTimestamp = firstItem.timestamp;\n  let accumTime = 0;\n  let currentGroup = [firstItem];\n  rest.forEach(item => {\n    accumTime += item.timestamp - prevTimestamp;\n    prevTimestamp = item.timestamp;\n    currentGroup.push(item);\n    while (accumTime >= groupMilis) {\n      accumTime -= groupMilis;\n      groups.push(currentGroup);\n      currentGroup = [];\n    }\n  });\n  if (currentGroup.length > 0) {\n    const groupTime = last(currentGroup).timestamp - currentGroup[0].timestamp;\n    if (groupTime < groupMilis / 2) {\n      last(groups).push(...currentGroup);\n    } else {\n      groups.push(currentGroup);\n    }\n  }\n  return groups;\n}\n\nexport function mistypedLast(\n  state: Pick<Typer.State, 'typed' | 'content'>\n) {\n  const { typed, content } = state;\n  const char = last(typed);\n  if (IGNORED_CHARACTERS.includes(char)) return false;\n\n  const wordsTyped = getWords(typed);\n  const lastWord = last(wordsTyped);\n  const actualWord = getWords(content.text)[wordsTyped.length - 1];\n\n  // it'd be like that sometimes\n  if (!actualWord) return false;\n\n  if (typed.endsWith(' ')) {\n    // not extra, missing\n    const missing = actualWord.length - lastWord.length;\n    return missing > 0;\n  }\n\n  const lastChar = lastWord[lastWord.length - 1];\n  const actualChar = actualWord[lastWord.length - 1];\n  return actualChar !== lastChar;\n}\n\nexport function timeSlice(\n  state: Typer.State, \n  from: number, \n  to: number,\n  overtime: boolean = false\n) {\n  let start = state.timeline.findIndex(i => i.timestamp >= from);\n  let end = state.timeline.findIndex(i => i.timestamp >= to);\n  if (start === -1) start = 0;\n  if (end === -1) end = state.timeline.length - 1;\n  if (overtime) {\n    if (start > 0) start--;\n    if (end < state.timeline.length - 1) end++;\n  }\n  return state.timeline.slice(start, end);\n}","import init from './init';\nimport typing from './typing';\nimport screen from './screen';\n\nconst ducers = {\n  init,\n  typing,\n  screen\n};\n\nexport default function reducer(\n  state: Typer.State | null, \n  action: Typer.Actions.Any) \n{\n  const r = ducers[action.type] as Reducer;\n  if (!r) return state;\n  return r(state, action);\n}\n\ntype Reducer = (state: Typer.State | null, action: Typer.Actions.Any) => Typer.State;","export default function init(\n  _state: Typer.State | null, \n  action: Typer.Actions.Init\n): Typer.State {\n  return {\n    content: action.content,\n    typed: '',\n    screen: 'typing',\n    temp: {\n      prevTime: 0,\n      delta: 0,\n      errors: 0,\n      count: 0\n    },\n    timeline: [],\n    config: {\n      fontFamily: 'monospace',\n      fontSize: 24,\n      lineHeight: 30,\n      width: 800, \n      colors: {\n        left: 'gray',\n        correct: 'white',\n        wrong: 'red',\n        extra: 'darkred',\n        caret: 'cyan'\n      }\n    }\n  }\n}","import { isDoneTyping } from '../util/handlers';\nimport { compose } from '../util/std';\nimport { IGNORED_CHARACTERS } from '../util/text';\n\nconst typing: (\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) => Typer.State =  compose(\n  setTyped,\n  addToTimeline,\n  setDone\n);\n\nexport default typing;\n\nfunction setTyped(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  let { typed } = state;\n  // dont add spaces together\n  if (char === ' ' && typed.endsWith(' ')) return state;\n  if (char === 'Backspace')\n    typed = typed.substr(0, typed.length - 1);\n  else typed = typed + char;\n  return { ...state, typed };\n}\n\nfunction addToTimeline(\n  state: Typer.State,\n  { char, time }: Typer.Actions.Typing\n) {\n  if (!state.typed) {\n    if (IGNORED_CHARACTERS.includes(char)) return state;\n  }\n  return {\n    ...state,\n    timeline: [\n      ...state.timeline,\n      { timestamp: time, char, typed: state.typed }\n    ]\n  };\n}\n\nfunction setDone(state: Typer.State) {\n  if (isDoneTyping(state))\n    return {\n      ...state,\n      screen: 'stats'\n    }\n  return state;\n}\n","export default function screen(\n  state: Typer.State, \n  action: Typer.Actions.Screen\n): Typer.State {\n  return {\n    ...state,\n    screen: action.screen\n  }\n}","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  position: Typer.CaretPosition | null;\n  focused: boolean;\n}\n\nfunction Caret({ position, focused }: Props) {\n  const { config, typed } = useTyper();\n  const [className, setClassName] = React.useState('caret');\n\n  React.useEffect(() => {\n    setClassName('caret');\n    const timeoutId = setTimeout(() => {\n      setClassName('caret animated');\n    }, 500);\n    return () => clearTimeout(timeoutId);\n  }, [typed]);\n\n  if (!position) return null;\n\n  return (\n    <span \n      className={className}\n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        transform: `translate(${position.x - 8}px, ${position.y - 2}px)`,\n        color: config.colors.caret,\n        visibility: focused ? 'visible' : 'hidden'\n      }}\n    >|\n    </span>\n  );\n} \n\nexport default Caret;","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  text?: string;\n  typed?: string;\n}\n\nfunction Char({ text, typed }: Props) {\n  const { config } = useTyper();\n  const code = React.useMemo(() => {\n    if (!typed) return 'left';\n    if (!text) return 'extra';\n    if (typed === text) return 'correct';\n    return 'wrong';\n  }, [text, typed]);\n  const color = config.colors[code]\n  const str = text || typed;\n  const className = ['Char', code].join(' ')\n  return (\n    <span className={className} style={{color}}>{str}</span>\n  );\n}\n\nexport default Char;","import Char from \"./Char\";\nimport { useTyper } from \"./Typer\";\nimport { tuplify } from \"../util/std\";\nimport { getChars, getExtra, getWidth } from \"../util/text\";\nimport '../styles/Word.css';\n\ninterface Props {\n  text: string;\n  typed: string;\n  current: boolean;\n}\n\nfunction Word({ text, typed, current }: Props) {\n  const { config } = useTyper();\n  const _chars = tuplify(\n    getChars(text),\n    getChars(typed),\n  );\n  const extraStr = getExtra(text, typed);\n  getChars(extraStr).forEach(char => {\n    _chars.push([null, char]);\n  });\n  const redline = !current && typed && text !== typed;\n  const className = [\n    \"Word\", \n    redline && 'redline',\n    current && 'current'\n  ].filter(c => c).join(' ');\n  const space = getWidth(' ', config);\n  return (\n    <div \n      className={className} \n      style={{\n        marginRight: space, \n        borderBottomColor: redline ? config.colors.wrong : 'transparent'\n      }}\n    >\n      {_chars.map(([text, typed], index) => \n        <Char \n          key={index}\n          text={text}\n          typed={typed}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default Word;","import React from 'react';\nimport { tuplify } from '../util/std';\nimport { getWords } from '../util/text'\nimport { useTyper, useTyperDispatch } from './Typer'\nimport Caret from './Caret';\nimport Word from './Word';\nimport '../styles/TypingTest.css';\nimport { useCaret } from '../hooks/typing-test';\n\nfunction TypingTest() {\n  const { content, typed, config } = useTyper();\n  const dispatch = useTyperDispatch();\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [inputHasFocus, setInputFocus] = React.useState(false);\n  const [capslock, setCapslock] = React.useState(false);\n  const caretPosition = useCaret(typed, config);\n\n  React.useEffect(() => {\n    inputRef.current?.focus();\n  }, [content.text]);\n\n  const typedWords = getWords(typed)\n  const _words = tuplify(\n    getWords(content.text),\n    typedWords,\n    [null, ...typedWords],\n    typedWords.slice(1)\n  )\n\n  function onKeyPress(e: React.KeyboardEvent<HTMLInputElement>) {\n    capslockDetector(e);\n    const char = e.key;\n    if (char.length === 1 || char === 'Backspace') {\n      dispatch({ type: 'typing', char, time: Date.now() });\n      e.preventDefault();\n      return;\n    }\n  }\n\n  function capslockDetector(e: React.KeyboardEvent<HTMLInputElement>) {\n    setCapslock(e.getModifierState('CapsLock'));\n  }\n\n  function isCurrent(word: string, prev: string, next: string) {\n    if (!typed && !prev) return true;\n    if (typed.endsWith(' ')) return prev != null && word == null;\n    return word != null && next == null;\n  }\n\n  const offset = React.useMemo(() => {\n    if (!caretPosition) return 0;\n    const line = Math.floor(caretPosition.y / config.lineHeight);\n    if (line < 1) return 0\n    return (line - 1) * config.lineHeight;\n  }, [caretPosition, config]);\n\n  const threeLinesHeight = config.lineHeight * 3 + 10 // 10px padding\n\n  return (\n    <div className=\"TypingTest\" style={{\n      fontFamily: config.fontFamily,\n      fontSize: config.fontSize + 'px',\n      lineHeight: (config.lineHeight - 1) + 'px', // 1px border bottom\n    }}>\n      <input \n        ref={inputRef}\n        onKeyDown={onKeyPress}\n        onKeyUp={capslockDetector}\n        style={{height: 0, padding: 0, border: 0, position: \"absolute\"}}\n        onFocus={() => setInputFocus(true)}\n        onBlur={() => setInputFocus(false)}\n      />\n      <p style={{visibility: capslock ? \"visible\" : \"hidden\"}}>\n        CAPSLOCK IS ACTIVE\n      </p>\n      <div className=\"threeLines\" style={{height: threeLinesHeight + 'px'}}>\n        <div \n          className=\"words\" \n          onClick={() => inputRef.current?.focus()}\n          style={{ maxWidth: config.width, transform: `translateY(${-offset}px)`}}\n        >\n          {_words.map(([text, typedWord, prevTyped, nextTyped], index) => \n            <Word\n              key={index}\n              text={text} \n              typed={typedWord}\n              current={isCurrent(typedWord, prevTyped, nextTyped)} \n            />\n          )}\n          <Caret position={caretPosition} focused={inputHasFocus} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default TypingTest;\n","import React from 'react';\nimport reducer from '../reducers';\nimport Screens from './Screens';\n\nexport * from '../util/handlers';\n\nconst StateContext = \n  React.createContext<Typer.State>(init({ text: '' })!);\nconst DispatchContext = \n  React.createContext<React.Dispatch<Typer.Actions.Any> | null>(null);\n\ninterface Props {\n  content: Typer.Content;\n  onType?(state: Typer.State): void;\n}\n\nexport function Typer({ content, onType }: Props) {\n  const [state, dispatch] = React.useReducer(reducer, null, () => init(content));\n\n  React.useEffect(() => {\n    dispatch({type: 'init', content });\n  }, [content]);\n\n  const prevTyped = React.useRef<string | null>(null);\n  React.useEffect(() => {\n    if (!onType || prevTyped.current === state!.typed) return;\n    if (prevTyped.current !== null) onType(state!);\n    prevTyped.current = state!.typed;\n  }, [state, onType]);\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state!}>\n        <Screens/>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n\nexport function useTyper() {\n  return React.useContext(StateContext);\n}\n\nexport function useTyperDispatch() {\n  return React.useContext(DispatchContext)!;\n}\n\nfunction init(content: Typer.Content) {\n  return reducer(null, { type: 'init', content });\n}","import React from 'react';\nimport { last } from '../util/std';\n\nexport function useCaret(typed: string, config: Typer.Config) {\n  const [pos, setPos] = React.useState<Typer.CaretPosition | null>(null);\n\n  React.useEffect(() => {\n    const wordEl = document.querySelector('.Word.current');\n    if (!wordEl) return;\n    const wordsEl = document.querySelector('.words')!;\n    const originRect = wordsEl.getBoundingClientRect();\n    const wrect = wordEl.getBoundingClientRect();\n    let charsTyped = wordEl.querySelectorAll('.Char:not(.left)');\n    if (charsTyped.length === 0) {\n      setPos({\n        x: wrect.left - originRect.left,\n        y: wrect.bottom - originRect.top - config.lineHeight\n      });\n      return;\n    }\n    const char = last(charsTyped);\n    const rect = char.getBoundingClientRect();\n    setPos({\n      x: rect.right - originRect.left,\n      y: wrect.bottom - originRect.top - config.lineHeight\n    });\n  }, [typed, config]);\n\n  return pos\n}","import React from 'react';\nimport { ComposedChart, Line, Scatter, CartesianGrid, XAxis, YAxis, Tooltip } from 'recharts';\nimport { netWpm, rawWpm, mistypedLast, timeSlice } from '../util/handlers';\nimport { last, tuplify } from '../util/std';\nimport { getChars, getWords, getExtra } from '../util/text';\nimport { useTyper } from './Typer';\nimport '../styles/Stats.css';\n\nfunction Stats() {\n  const state = useTyper();\n  const { content, typed, config } = state;\n\n  const counts = charCounts(content.text, typed);\n  const startTime = state.timeline[0].timestamp;\n  const duration = (last(state.timeline).timestamp - startTime) / 1000;\n\n  const chartData = React.useMemo(() => {\n    const data = Array\n      .from({ length: Math.round(duration)  })\n      .map((_, index) => {\n        return { \n          second: index + 1, \n          wpm: wpmPoint(state, index),\n          raw: slicePoint(state, index), \n          errors: errorPoint(state, index)\n        };\n      });\n    last(data).second = duration;\n    return data;\n  }, [state, duration]);\n\n  const acc = React.useMemo(() => {\n    const total = getWords(content.text).join('').length;\n    const errors = chartData.reduce((sum, d) => (\n      d.errors ? sum + d.errors : sum\n    ), 0)\n    return (1 - errors / total) * 100;\n  }, [chartData, content]);\n\n  return (\n    <div className=\"Stats\">\n      <div className=\"wpm\">\n        <h3>wpm</h3>\n        <h2>{Math.round(netWpm(state))}</h2>\n      </div>\n      <div className=\"acc\">\n        <h3>acc</h3>\n        <h2>{Math.round(acc)}%</h2>\n      </div>\n      <div className=\"chart\">\n        <ComposedChart width={config.width} height={300} data={chartData}>\n          <Line type=\"monotone\" yAxisId=\"wpm\" dataKey=\"raw\" stroke=\"darkred\" fill=\"darkred\"/>\n          <Line type=\"monotone\" yAxisId=\"wpm\" dataKey=\"wpm\" stroke=\"red\" fill=\"red\"/>\n          <Scatter type=\"monotone\" yAxisId=\"errors\" dataKey=\"errors\" stroke=\"black\" fill=\"gray\"/>\n          <CartesianGrid stroke=\"#fff3\" strokeDasharray=\"5 5\" />\n          <XAxis \n            type=\"number\" \n            dataKey=\"second\" \n            tickCount={10}\n            domain={[1, 'dataMax']}\n            allowDecimals={false}\n          />\n          <YAxis yAxisId=\"wpm\"/>\n          <YAxis yAxisId=\"errors\" orientation=\"right\" allowDecimals={false}/>\n          <Tooltip/>\n        </ComposedChart>\n      </div>\n      <div className=\"raw\">\n        <h3>raw</h3>\n        <h2>{Math.round(rawWpm(state))}</h2>\n      </div>\n      <div className=\"chars\">\n        <h3>characters</h3>\n        <h2>{counts.correct}/{counts.incorrect}/{counts.extra}/{counts.missing}</h2>\n      </div>\n      <div className=\"time\">\n        <h3>time</h3>\n        <h2>{Math.round(duration)}s</h2>\n      </div>\n    </div>\n  )\n}\n\nexport default Stats;\n\nfunction charCounts(text: string, typed: string) {\n  let correct = 0, incorrect = 0, missing = 0, extras = 0\n  tuplify(\n    getWords(text),\n    getWords(typed)\n  ).forEach(([wtext, wtyped]) => {\n    tuplify(\n      getChars(wtext),\n      getChars(wtyped)\n    ).forEach(([chtext, chtyped]) => {\n      if (!chtyped) missing++;\n      else if (chtext === chtyped) correct++;\n      else incorrect++;\n    });\n    getChars(getExtra(wtext, wtyped)).forEach(() => extras++);\n    correct++; // spaces\n  });\n  correct--; // does not end with space\n  return {correct, incorrect, missing, extra: extras }\n}\n\nfunction slicePoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime + (second - 1) * 1000,\n    startTime + (second + 2) * 1000,\n    false\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice).typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return Math.round(rawWpm(st));\n}\n\nfunction wpmPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime,\n    startTime + (second + 1) * 1000,\n    true\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice).typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return Math.round(netWpm(st));\n}\n\nfunction errorPoint(state: Typer.State, second: number) {\nconst startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime + second * 1000,\n    startTime + (second + 1) * 1000,\n    false\n  );\n  if (slice.length === 0) return null;\n  return slice.reduce((errs, item) => {\n    return errs + Number(mistypedLast({\n      typed: item.typed,\n      content: state.content\n    }));\n  }, 0) || null;\n}\n","import TypingTest from './TypingTest';\nimport Stats from './Stats';\nimport { useTyper } from './Typer';\n\nfunction Screens() {\n\n  const { screen } = useTyper();\n\n  return screen === 'stats' \n        ? <Stats />\n        : <TypingTest />;\n}\n\nexport default Screens;","import React from 'react';\nimport { Typer } from '../../components/Typer';\n\nconst QUOTES_URL = process.env.REACT_APP_QUOTES_URL!;\n\nfunction Quotes() {\n  const [quotes, setQuotes] = React.useState<Typer.Content[]>([]);\n  const [index, setIndex] = React.useState(-1);\n\n  React.useEffect(() => {\n    fetch(QUOTES_URL)\n      .then(r => r.json())\n      .then(({ quotes }) => {\n        setQuotes(quotes);\n        setIndex(rand(quotes.length));\n      });\n  }, [])\n\n  const onType = React.useCallback(t => {\n    // console.log(t);\n  }, []);\n\n  if (index === -1) return <div>Loading...</div>;\n\n  return (\n    <>\n      <Typer content={quotes[index]} onType={onType}/>\n      <button onClick={() => setIndex(rand(quotes.length))}>Next</button>\n    </>\n  );\n}\n\nexport default Quotes;\n\n\nfunction rand(count: number) {\n  return Math.floor(Math.random() * count);\n}","import React from 'react';\nimport { Typer, lastWpm, isDoneTyping, netWpm } from \"../../components/Typer\";\nimport { clamp } from '../../util/std';\nconst audios = [\n  undefined,\n  require('./audios/1.wav').default,\n  require('./audios/2.wav').default,\n  require('./audios/3.wav').default,\n  require('./audios/4.wav').default,\n  require('./audios/5.wav').default,\n  require('./audios/6.wav').default,\n  require('./audios/7.wav').default,\n]\n\nconst audioClamp = clamp(1, audios.length - 1);\n\nfunction Yoshi() {\n  const [content, setContent] = \n    React.useState<Typer.Content | null>(null);\n  const [track, setTrack] = React.useState(0);\n  const [timeoutId, setTimeoutId] = React.useState<NodeJS.Timeout | null>(null)\n  const refs = React.useRef<HTMLAudioElement[]>([]);\n\n  React.useLayoutEffect(() => {\n    const audioProm = Promise.all(\n      refs.current.map(el => {\n        el.load();\n        return new Promise(resolve => {\n          el.oncanplay = () => resolve(el);\n        })\n      })\n    );\n    fetch('/nancio-type/yoshi.txt').then(async r => {\n      const text = await r.text();\n      await audioProm;\n      setContent({ text });\n    });\n  }, []);\n\n  function onType(state: Typer.State) {\n    if (timeoutId) clearTimeout(timeoutId);\n    if (isDoneTyping(state)) {\n      const net = netWpm(state);\n      const index = audioClamp(Math.floor(net / 15));\n      setTrack(index);\n      return;\n    }\n    const wpm = lastWpm(state);\n    const index = audioClamp(Math.floor(wpm / 15));\n    setTrack(index);\n    refs.current.forEach(e => {\n      e.play();\n    });\n    const id = setTimeout(() => {\n      setTrack(0);\n      refs.current.forEach(e => {\n        e.pause();\n        e.currentTime = 0;\n      })\n    }, 1000);\n    setTimeoutId(id);\n  }\n\n  if (!content) return <div>Loading...</div>;\n  return (\n    <>\n      {audios.map((src, index) => src &&\n        <audio \n          key={index} \n          ref={r => refs.current[index - 1] = r!}\n          muted={index !== track}\n          preload=\"auto\"\n          loop \n        >\n          <source src={src} type=\"audio/wav\"/>\n        </audio>\n      ) }\n      <Typer content={content} onType={onType}/>\n    </>\n  );\n}\n\nexport default Yoshi;","import { HashRouter, Switch, Route, Redirect } from 'react-router-dom';\nimport Quotes from './quotes/Quotes';\nimport Yoshi from './yoshi/Yoshi';\n\nfunction Router() {\n  return (\n    <HashRouter>\n      <Switch>\n        <Route path=\"/quotes\">\n          <Quotes/>\n        </Route>\n        <Route path=\"/yoshi\">\n          <Yoshi/>\n        </Route>\n        <Redirect to=\"/quotes\"/>\n      </Switch>\n    </HashRouter>\n  );\n}\n\nexport default Router;","import './App.css';\nimport Router from './pages';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Router/>\n      </header>\n    </div>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
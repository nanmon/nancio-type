{"version":3,"sources":["../node_modules/lodash/clamp.js","../node_modules/lodash/_baseClamp.js","pages/yoshi/audios/1.wav","util/text.ts","pages/yoshi/audios/2.wav","pages/yoshi/audios/3.wav","pages/yoshi/audios/4.wav","pages/yoshi/audios/5.wav","pages/yoshi/audios/6.wav","pages/yoshi/audios/7.wav","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","pages/yoshi/Yoshi.tsx","util/handlers.ts","reducers/merge.ts","reducers/index.ts","reducers/init.ts","reducers/typing.ts","reducers/screen.ts","components/Caret.tsx","components/Char.tsx","components/Word.tsx","components/Line.tsx","components/TypingTest.tsx","components/Stats.tsx","components/Screens.tsx","components/Typer.tsx"],"names":["baseClamp","require","toNumber","module","exports","number","lower","upper","undefined","IGNORED_CHARACTERS","IGNORED_MODIFIERS","getWords","text","split","filter","w","getChars","getExtra","typed","length","substr","getWidth","fontFamily","fontSize","context","document","createElement","getContext","font","measureText","width","getLines","typedWords","words","zip","currentLength","currentLine","lines","forEach","word","wlength","push","trim","getCaretPosition","wcount","lineIndex","findIndex","line","lwords","charIndex","slice","join","endsWith","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","audios","default","Yoshi","React","useState","content","setContent","track","setTrack","timeoutId","setTimeoutId","refs","useRef","useLayoutEffect","audioProm","all","current","map","el","load","oncanplay","fetch","fn","r","a","self","this","args","arguments","apply","err","src","index","ref","muted","preload","loop","type","Typer","onType","state","clearTimeout","isDoneTyping","net","netWpm","clamp","Math","floor","wpm","lastWpm","e","play","id","setTimeout","pause","currentTime","milis","timeline","endTime","last","timestamp","timeSlice","st","rawWpm","allWords","pop","errors","typedWord","typedChar","unfixedErrors","typedMilis","i","includes","char","typedCount","mistypedLast","wordsTyped","lastWord","actualWord","lastChar","from","to","overtime","start","end","merge","ducers","init","action","reset","screen","temp","prevTime","delta","count","config","lineHeight","colors","left","correct","wrong","extra","caret","typing","newState","setTyped","setDone","time","addToTimeline","Object","entries","some","val","reducer","Caret","position","focused","useTyper","className","setClassName","useEffect","x","y","charWidth","clampedY","style","top","transform","color","visibility","Char","memo","code","useMemo","str","Word","_chars","redline","c","space","marginRight","borderBottomColor","Line","prev","next","prevTyped","nextTyped","TypingTest","onKeyPress","dispatch","useTyperDispatch","inputRef","inputHasFocus","setInputFocus","capslock","setCapslock","focus","capslockDetector","getModifierState","drawingLines","threeLinesHeight","onKeyDown","mod","Date","now","preventDefault","onKeyUp","height","padding","border","onFocus","onBlur","onClick","Stats","counts","incorrect","missing","extras","wtext","wtyped","chtext","chtyped","charCounts","startTime","duration","chartData","data","Array","round","_","second","wpmPoint","raw","slicePoint","errorPoint","typedPoint","acc","total","reduce","sum","d","ComposedChart","yAxisId","dataKey","stroke","fill","Scatter","CartesianGrid","strokeDasharray","XAxis","tickCount","domain","allowDecimals","YAxis","orientation","Tooltip","errs","item","Number","Screens","StateContext","createContext","DispatchContext","restartOnContentChange","useReducer","Provider","useContext"],"mappings":"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","file":"static/js/5.f8b9386a.chunk.js","sourcesContent":["var baseClamp = require('./_baseClamp'),\n    toNumber = require('./toNumber');\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n","/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n","export default __webpack_public_path__ + \"static/media/1.d7420ab5.wav\";","import zip from 'lodash/zip';\n\nexport const IGNORED_CHARACTERS = ['', 'Backspace'];\nexport const IGNORED_MODIFIERS = ['Alt', 'AltGraph', 'Control', 'Fn', 'Meta', 'OS']\n\nexport const getWords = (text = '') => {\n  return text.split(' ').filter(w => w);\n}\n\nexport const getChars = (text = '') => {\n  return text.split('');\n}\n\nexport const getExtra = (text: string, typed = '') => {\n  if (typed.length > text.length)\n    return typed.substr(text.length);\n  return '';\n}\n\nexport const withExtra = (text: string, typed: string) => {\n  const wtext = getWords(text);\n  const wtyped = getWords(typed);\n  return zip(wtext, wtyped).map(([text, typed]) => {\n    return text + getExtra(text!, typed);\n  }).join(' ');\n}\n\nexport const getWidth = (\n  text: string, \n  {fontFamily, fontSize}: {fontFamily: string, fontSize: number}\n) => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context!.font = `${fontSize}px ${fontFamily}`;\n  return context!.measureText(text).width;\n}\n\nexport const getLines = (\n  text: string, \n  typed: string, \n  { width }: { width: number }\n) => {\n  const typedWords = getWords(typed)\n  const words = zip(\n    getWords(text),\n    typedWords,\n  )\n  let currentLength = 0;\n  let currentLine: [string, string] = ['', '']\n  const lines: [string, string][] = [];\n  words.forEach(([word, typed]) => {\n    if (!word) return;\n    let wlength = word.length;\n    if (typed && typed.length > word.length) wlength = typed.length;\n    if (currentLength + 1 + wlength > width) {\n      currentLength = wlength;\n      lines.push([\n        currentLine[0].trim(),\n        currentLine[1].trim()\n      ]);\n      currentLine = [word, typed || '']\n    } else {\n      currentLength += 1 + wlength;\n      currentLine[0] += ' ' + word;\n      if (typed) currentLine[1] += ' ' + typed;\n    }\n  });\n  if (currentLine.length > 0) lines.push(currentLine);\n  return lines;\n}\n\nexport const getCaretPosition = (lines: string[], typed: string): [number, number] => {\n  const words = getWords(typed);\n  let wcount = 0;\n  const lineIndex = lines.findIndex(line => {\n    const lwords = getWords(line);\n    if (wcount + lwords.length >= words.length) return true;\n    wcount += lwords.length;\n    return false;\n  });\n  const lastWords = words.slice(wcount);\n  let charIndex = lastWords.join(' ').length;\n  if (typed.endsWith(' ')) charIndex++;\n  return [charIndex, lineIndex];\n}","export default __webpack_public_path__ + \"static/media/2.9ee81949.wav\";","export default __webpack_public_path__ + \"static/media/3.c5b467d3.wav\";","export default __webpack_public_path__ + \"static/media/4.0f83ee86.wav\";","export default __webpack_public_path__ + \"static/media/5.1c9b447b.wav\";","export default __webpack_public_path__ + \"static/media/6.d6666621.wav\";","export default __webpack_public_path__ + \"static/media/7.a1d42fec.wav\";","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import React from 'react';\nimport clamp from 'lodash/clamp';\nimport { Typer, lastWpm, isDoneTyping, netWpm } from \"../../components/Typer\";\nconst audios = [\n  undefined,\n  require('./audios/1.wav').default,\n  require('./audios/2.wav').default,\n  require('./audios/3.wav').default,\n  require('./audios/4.wav').default,\n  require('./audios/5.wav').default,\n  require('./audios/6.wav').default,\n  require('./audios/7.wav').default,\n]\n\n// const audioClamp = clamp(1, audios.length - 1);\n\nfunction Yoshi() {\n  const [content, setContent] = \n    React.useState<Typer.Content | null>(null);\n  const [track, setTrack] = React.useState(0);\n  const [timeoutId, setTimeoutId] = React.useState<NodeJS.Timeout | null>(null)\n  const refs = React.useRef<HTMLAudioElement[]>([]);\n\n  React.useLayoutEffect(() => {\n    const audioProm = Promise.all(\n      refs.current.map(el => {\n        el.load();\n        return new Promise(resolve => {\n          el.oncanplay = () => resolve(el);\n        })\n      })\n    );\n    fetch('/nancio-type/yoshi.txt').then(async r => {\n      const text = await r.text();\n      await audioProm;\n      setContent({ text });\n    });\n  }, []);\n\n  function onType(state: Typer.State) {\n    if (timeoutId) clearTimeout(timeoutId);\n    if (isDoneTyping(state)) {\n      const net = netWpm(state);\n      const index = clamp(Math.floor(net / 15), 1, audios.length - 1);\n      setTrack(index);\n      return;\n    }\n    const wpm = lastWpm(state);\n    const index = clamp(Math.floor(wpm / 15), 1, audios.length - 1);\n    setTrack(index);\n    refs.current.forEach(e => {\n      e.play();\n    });\n    const id = setTimeout(() => {\n      setTrack(0);\n      refs.current.forEach(e => {\n        e.pause();\n        e.currentTime = 0;\n      })\n    }, 1000);\n    setTimeoutId(id);\n  }\n\n  if (!content) return <div>Loading...</div>;\n  return (\n    <>\n      {audios.map((src, index) => src &&\n        <audio \n          key={index} \n          ref={r => refs.current[index - 1] = r!}\n          muted={index !== track}\n          preload=\"auto\"\n          loop \n        >\n          <source src={src} type=\"audio/wav\"/>\n        </audio>\n      ) }\n      <Typer content={content} onType={onType}/>\n    </>\n  );\n}\n\nexport default Yoshi;","import zip from 'lodash/zip';\nimport last from 'lodash/last'\nimport { getChars, getExtra, getWords, IGNORED_CHARACTERS } from \"./text\";\n\nexport function didType(state: Typer.State, str: string) {\n  const { typed, content } = state;\n  const startIndex = content.text.indexOf(str);\n  if (startIndex === -1)\n    throw Error('string not found in text');\n  const endIndex = startIndex + str.length;\n  const substr = content.text.substr(0, endIndex);\n  const subWords = getWords(substr);\n  const typedWords = getWords(typed);\n  return typedWords.length >= subWords.length;\n}\n\nexport function wordStats(state: Typer.State, wordIndex: number) {\n  const { typed, content } = state;\n  const stats = { left: 0, correct: 0, extra: 0, wrong: 0 }\n  const word = getWords(content.text)[wordIndex];\n  const typedWord = getWords(typed)[wordIndex];\n  if (!typedWord) {\n    stats.left = word.length;\n    return stats;\n  }\n  zip(\n    getChars(word),\n    getChars(typedWord),\n  ).forEach(([char, typedChar]) => {\n    if (!typedChar) stats.left++;\n    else if (char === typedChar) stats.correct++;\n    else stats.wrong++;\n  });\n  const extraStr = getExtra(word, typedWord);\n  getChars(extraStr).forEach(() => {\n    stats.extra++;\n  });\n  return stats;\n}\n\nexport function lastWpm(state: Typer.State, milis = 5000) {\n  if (state.timeline.length === 0) return 0;\n  const endTime = last(state.timeline)!.timestamp;\n  let slice = timeSlice(\n    state, \n    endTime - milis,\n    endTime + 1000,\n    false\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice)!.typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return rawWpm(st);\n}\n\nexport function isDoneTyping({ typed, content }: Typer.State) {\n  const typedWords = getWords(typed);\n  const allWords = getWords(content.text);\n  if (typedWords.length < allWords.length) return false;\n  if (typed.endsWith(' ')) return true;\n  const lastTyped = typedWords.pop();\n  const lastWord = allWords.pop();\n  return lastTyped === lastWord;\n}\n\nexport function netWpm(state: Pick<Typer.State, 'timeline' | 'content' | 'typed'>) {\n  return rawWpm(state) - unfixedErrors(state) / typedMilis(state) * 1000 * 60;\n}\n\nexport function rawWpm(state: Pick<Typer.State, 'timeline'>) {\n  return typedCount(state) / typedMilis(state) * 1000 * 60 / 5;\n}\n\nexport function typedCount(state: Pick<Typer.State, 'timeline'>) {\n  return state.timeline\n    .filter(i => !IGNORED_CHARACTERS.includes(i.char))\n    .length;\n}\n\nexport function typedMilis(state: Pick<Typer.State, 'timeline'>) {\n  if (state.timeline.length === 0) return 0;\n  return last(state.timeline)!.timestamp - state.timeline[0].timestamp;\n}\n\nexport function unfixedErrors(state: Pick<Typer.State, 'typed' | 'content'>) {\n  let errors = 0;\n  const typedWords = getWords(state.typed);\n  zip(\n    typedWords,\n    getWords(state.content.text),\n  ).forEach(([typedWord, word], index) => {\n    if (!word || !typedWord) return; // should not happen\n    if (index < typedWords.length -1 && word.length > typedWord!.length) {\n      errors++; // all missings as one error\n    }\n    zip(\n      getChars(typedWord),\n      getChars(word),\n    ).forEach(([typedChar, char]) => {\n      if (char === typedChar) return;\n      errors++; // extras and incorrects\n    });\n  });\n  return errors;\n}\n\nexport function groupTimeline(\n  state: Typer.State, \n  groupMilis: number = 1000\n): Typer.TimelineItem[][] {\n  let groups: Typer.TimelineItem[][] = [];\n  let [firstItem, ...rest] = state.timeline;\n  let prevTimestamp = firstItem.timestamp;\n  let accumTime = 0;\n  let currentGroup = [firstItem];\n  rest.forEach(item => {\n    accumTime += item.timestamp - prevTimestamp;\n    prevTimestamp = item.timestamp;\n    currentGroup.push(item);\n    while (accumTime >= groupMilis) {\n      accumTime -= groupMilis;\n      groups.push(currentGroup);\n      currentGroup = [];\n    }\n  });\n  if (currentGroup.length > 0) {\n    const groupTime = last(currentGroup)!.timestamp - currentGroup[0].timestamp;\n    if (groupTime < groupMilis / 2 && groups.length > 0) {\n      last(groups)!.push(...currentGroup);\n    } else {\n      groups.push(currentGroup);\n    }\n  }\n  return groups;\n}\n\nexport function mistypedLast(\n  state: Pick<Typer.State, 'typed' | 'content'>\n) {\n  const { typed, content } = state;\n  if (!typed) return false;\n  const char = last(typed)!;\n  if (IGNORED_CHARACTERS.includes(char)) return false;\n\n  const wordsTyped = getWords(typed);\n  const lastWord = last(wordsTyped)!;\n  const actualWord = getWords(content.text)[wordsTyped.length - 1];\n\n  // it'd be like that sometimes\n  if (!actualWord) return false;\n\n  if (typed.endsWith(' ')) {\n    // not extra, missing\n    const missing = actualWord.length - lastWord.length;\n    return missing > 0;\n  }\n\n  const lastChar = lastWord[lastWord.length - 1];\n  const actualChar = actualWord[lastWord.length - 1];\n  return actualChar !== lastChar;\n}\n\nexport function timeSlice(\n  state: Typer.State, \n  from: number, \n  to: number,\n  overtime: boolean = false\n) {\n  let start = state.timeline.findIndex(i => i.timestamp >= from);\n  let end = state.timeline.findIndex(i => i.timestamp >= to);\n  if (start === -1) start = 0;\n  if (end === -1) end = state.timeline.length - 1;\n  if (overtime) {\n    if (start > 0) start--;\n    if (end < state.timeline.length - 1) end++;\n  }\n  return state.timeline.slice(start, end);\n}","function merge(state: Typer.State, action: Typer.Actions.Merge): Typer.State {\n  let diff = Object.entries(action.state)\n    .some(([key, val]) => state[key] !== val);\n  if (!diff) return state;\n  return {\n    ...state,\n    ...action.state,\n  }\n}\n\nexport default merge;","import init from './init';\nimport typing from './typing';\nimport screen from './screen';\nimport merge from './merge';\n\nconst ducers = {\n  init,\n  typing,\n  screen,\n  merge,\n};\n\nexport default function reducer(\n  state: Typer.State | null, \n  action: Typer.Actions.Any) \n{\n  const r = ducers[action.type] as Reducer;\n  if (!r) return state;\n  return r(state, action);\n}\n\ntype Reducer = (state: Typer.State | null, action: Typer.Actions.Any) => Typer.State;","export default function init(\n  state: Typer.State | null, \n  action: Typer.Actions.Init\n): Typer.State {\n  if (!action.reset) {\n    return {\n      ...state!,\n      content: action.content,\n      timeline: []\n    }\n  }\n  return {\n    content: action.content,\n    typed: '',\n    screen: 'typing',\n    temp: {\n      prevTime: 0,\n      delta: 0,\n      errors: 0,\n      count: 0\n    },\n    timeline: [],\n    config: {\n      fontFamily: 'monospace',\n      fontSize: 24,\n      lineHeight: 30,\n      width: 60, \n      colors: {\n        left: 'gray',\n        correct: 'white',\n        wrong: 'red',\n        extra: 'darkred',\n        caret: 'cyan'\n      }\n    }\n  }\n}","import { isDoneTyping } from '../util/handlers';\nimport { IGNORED_CHARACTERS } from '../util/text';\n\nconst typing = (\n  state: Typer.State, \n  action: Typer.Actions.Typing\n) => {\n  let newState = setTyped(state, action);\n  newState = addToTimeline(newState, action);\n  return setDone(newState);\n}\n\nexport default typing;\n\nfunction setTyped(\n  state: Typer.State, \n  { char }: Typer.Actions.Typing\n) {\n  let { typed } = state;\n  // dont add spaces together\n  if (char === ' ' && typed.endsWith(' ')) return state;\n  if (char === 'Backspace')\n    typed = typed.substr(0, typed.length - 1);\n  else typed = typed + char;\n  return { ...state, typed };\n}\n\nfunction addToTimeline(\n  state: Typer.State,\n  { char, time }: Typer.Actions.Typing\n) {\n  if (!state.typed) {\n    if (IGNORED_CHARACTERS.includes(char)) return state;\n  }\n  return {\n    ...state,\n    timeline: [\n      ...state.timeline,\n      { timestamp: time, char, typed: state.typed }\n    ]\n  };\n}\n\nfunction setDone(state: Typer.State) {\n  if (isDoneTyping(state))\n    return {\n      ...state,\n      screen: 'stats'\n    }\n  return state;\n}\n","export default function screen(\n  state: Typer.State, \n  action: Typer.Actions.Screen\n): Typer.State {\n  return {\n    ...state,\n    screen: action.screen\n  }\n}","import React from 'react';\nimport { getWidth } from '../util/text';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  position: [number, number];\n  focused: boolean;\n}\n\nfunction Caret({ position, focused }: Props) {\n  const { config, typed } = useTyper();\n  const [className, setClassName] = React.useState('caret');\n\n  React.useEffect(() => {\n    setClassName('caret');\n    const timeoutId = setTimeout(() => {\n      setClassName('caret animated');\n    }, 500);\n    return () => clearTimeout(timeoutId);\n  }, [typed]);\n\n  if (!position) return null;\n  const [x, y] = position;\n  const charWidth = getWidth('a', config);\n  const clampedY = y ? 1 : 0;\n  return (\n    <span \n      className={className}\n      style={{ \n        position: 'absolute', \n        top: 0, \n        left: 0, \n        transform: `translate(${x * charWidth + 3}px, ${clampedY * config.lineHeight + 5}px)`,\n        color: config.colors.caret,\n        visibility: focused ? 'visible' : 'hidden'\n      }}\n    >|\n    </span>\n  );\n} \n\nexport default Caret;","import React from 'react';\nimport { useTyper } from \"./Typer\";\n\ninterface Props {\n  text?: string;\n  typed?: string;\n}\n\nconst Char = React.memo(function Char({ text, typed }: Props) {\n  const { config } = useTyper();\n  const code = React.useMemo(() => {\n    if (!typed) return 'left';\n    if (!text) return 'extra';\n    if (typed === text) return 'correct';\n    return 'wrong';\n  }, [text, typed]);\n  const color = config.colors[code]\n  const str = text || typed;\n  const className = ['Char', code].join(' ')\n  return (\n    <span className={className} style={{color}}>{str}</span>\n  );\n});\n\nexport default Char;","import React from \"react\";\nimport zip from 'lodash/zip';\nimport Char from \"./Char\";\nimport { useTyper } from \"./Typer\";\nimport { getChars, getWidth } from \"../util/text\";\nimport '../styles/Word.css';\n\ninterface Props {\n  text: string;\n  typed?: string;\n  current: boolean;\n}\n\nconst Word = React.memo(function Word({ text, typed, current }: Props) {\n  const { config } = useTyper();\n  const _chars = zip(\n    getChars(text),\n    getChars(typed),\n  );\n  const redline = !current && typed && text !== typed;\n  const className = [\n    \"Word\", \n    redline && 'redline',\n    current && 'current'\n  ].filter(c => c).join(' ');\n  const space = getWidth(' ', config);\n  return (\n    <div \n      className={className} \n      style={{\n        marginRight: space, \n        borderBottomColor: redline ? config.colors.wrong : 'transparent'\n      }}\n    >\n      {_chars.map(([text, typed], index) => \n        <Char \n          key={index}\n          text={text}\n          typed={typed}\n        />\n      )}\n    </div>\n  );\n});\n\nexport default Word;","import React from 'react';\nimport zip from 'lodash/zip';\nimport { getWords } from '../util/text';\nimport Word from './Word';\nimport '../styles/Line.css';\n\ninterface Props {\n  text: string;\n  typed: string;\n}\n\nconst Line = React.memo(function Line({ text, typed }: Props) {\n  const typedWords = getWords(typed);\n  const words = zip(\n    getWords(text),\n    typedWords,\n    [undefined, ...typedWords],\n    typedWords.slice(1)\n  )\n\n  function isCurrent(word?: string, prev?: string, next?: string) {\n    if (!typed && !prev) return true;\n    if (typed.endsWith(' ')) return prev != null && word == null;\n    return word != null && next == null;\n  }\n\n  return (\n    <div className=\"Line\">\n      {words.map(([text, typedWord, prevTyped, nextTyped], index) => \n        text && <Word\n          key={index}\n          text={text} \n          typed={typedWord}\n          current={isCurrent(typedWord, prevTyped, nextTyped)} \n        />\n      )}\n    </div>\n  );\n});\n\nexport default Line;","import React from 'react';\nimport { getCaretPosition, getLines, getWidth, IGNORED_MODIFIERS } from '../util/text'\nimport { useTyper, useTyperDispatch } from './Typer'\nimport Caret from './Caret';\nimport '../styles/TypingTest.css';\nimport Line from './Line';\n\ninterface Props {\n  onKeyPress(\n    e: React.KeyboardEvent<HTMLInputElement>,\n    direction: 'up' | 'down'\n  ): boolean;\n}\n\nfunction TypingTest({ onKeyPress }: Props) {\n  const { content, typed, config } = useTyper();\n  const dispatch = useTyperDispatch();\n\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const [inputHasFocus, setInputFocus] = React.useState(false);\n  const [capslock, setCapslock] = React.useState(false);\n\n  React.useEffect(() => {\n    inputRef.current?.focus();\n  }, [content.text]);\n\n  const lines = React.useMemo(() => {\n   return getLines(content.text, typed, config); \n  }, [typed, content, config]);\n\n  const caret = React.useMemo(() => {\n    return getCaretPosition(lines.map(([t]) => t), typed);\n  }, [lines, typed]);\n\n  function keyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    capslockDetector(e);\n    if (onKeyPress(e, 'down')) return;\n    const char = e.key;\n    const ignore = IGNORED_MODIFIERS.some(mod => {\n      return e.getModifierState(mod);\n    })\n    if (ignore) return;\n    if (char.length === 1 || char === 'Backspace') {\n      dispatch({ type: 'typing', char, time: Date.now() });\n      e.preventDefault();\n      return;\n    }\n  }\n\n  function keyUp(e: React.KeyboardEvent<HTMLInputElement>) {\n    onKeyPress(e, 'up');\n    capslockDetector(e);\n  }\n\n  function capslockDetector(e: React.KeyboardEvent<HTMLInputElement>) {\n    setCapslock(e.getModifierState('CapsLock'));\n  }\n\n  const drawingLines = React.useMemo(() => {\n    if (caret[1] < 2) return lines.slice(0, 3);\n    return lines.slice(caret[1] - 1, caret[1] + 2);\n  }, [lines, caret]);\n\n  const threeLinesHeight = config.lineHeight * 3 + 10 // 10px padding\n\n  return (\n    <div className=\"TypingTest\" style={{\n      fontFamily: config.fontFamily,\n      fontSize: config.fontSize + 'px',\n      lineHeight: (config.lineHeight - 1) + 'px', // 1px border bottom\n    }}>\n      <input \n        ref={inputRef}\n        onKeyDown={keyDown}\n        onKeyUp={keyUp}\n        style={{height: 0, padding: 0, border: 0, position: \"absolute\"}}\n        onFocus={() => setInputFocus(true)}\n        onBlur={() => setInputFocus(false)}\n      />\n      <p style={{visibility: capslock ? \"visible\" : \"hidden\"}}>\n        CAPSLOCK IS ACTIVE\n      </p>\n      <div className=\"threeLines\" style={{\n        height: threeLinesHeight + 'px',\n        width: config.width * getWidth('a', config)\n      }}>\n        <div \n          className=\"words\" \n          onClick={() => inputRef.current?.focus()}\n          style={{ transform: `translateY(0px)`}}\n        >\n          {drawingLines.map(([text, typed]) => \n            text && <Line\n              key={text}\n              text={text} \n              typed={typed}\n            />\n          )}\n          <Caret position={caret} focused={inputHasFocus} />\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default TypingTest;\n","import React from 'react';\nimport last from 'lodash/last';\nimport zip from 'lodash/zip';\nimport { ComposedChart, Line, Scatter, CartesianGrid, XAxis, YAxis, Tooltip } from 'recharts';\nimport { netWpm, rawWpm, mistypedLast, timeSlice } from '../util/handlers';\nimport { getChars, getWords } from '../util/text';\nimport { useTyper } from './Typer';\nimport '../styles/Stats.css';\n\nfunction Stats() {\n  const state = useTyper();\n  const { content, typed, config } = state;\n\n  const counts = charCounts(content.text, typed);\n  const startTime = state.timeline[0].timestamp;\n  const duration = (last(state.timeline)!.timestamp - startTime) / 1000;\n\n  const chartData = React.useMemo(() => {\n    debugger;\n    const data = Array\n      .from({ length: Math.round(duration)  })\n      .map((_, index) => {\n        return { \n          second: index + 1, \n          wpm: wpmPoint(state, index),\n          raw: slicePoint(state, index), \n          errors: errorPoint(state, index),\n          typed: typedPoint(state, index)\n        };\n      });\n    last(data)!.second = duration;\n    return data;\n  }, [state, duration]);\n\n  const acc = React.useMemo(() => {\n    const total = getWords(content.text).join('').length;\n    const errors = chartData.reduce((sum, d) => (\n      d.errors ? sum + d.errors : sum\n    ), 0)\n    return (1 - errors / total) * 100;\n  }, [chartData, content]);\n\n  return (\n    <div className=\"Stats\">\n      <div className=\"wpm\">\n        <h3>wpm</h3>\n        <h2>{Math.round(netWpm(state))}</h2>\n      </div>\n      <div className=\"acc\">\n        <h3>acc</h3>\n        <h2>{Math.round(acc)}%</h2>\n      </div>\n      <div className=\"chart\">\n        <ComposedChart width={config.width * 15} height={300} data={chartData}>\n          <Line type=\"monotone\" yAxisId=\"wpm\" dataKey=\"raw\" stroke=\"darkred\" fill=\"darkred\"/>\n          <Line type=\"monotone\" yAxisId=\"wpm\" dataKey=\"wpm\" stroke=\"red\" fill=\"red\"/>\n          <Scatter type=\"monotone\" yAxisId=\"errors\" dataKey=\"errors\" stroke=\"black\" fill=\"gray\"/>\n          <CartesianGrid stroke=\"#fff3\" strokeDasharray=\"5 5\" />\n          <XAxis \n            type=\"number\" \n            dataKey=\"second\" \n            tickCount={10}\n            domain={[1, 'dataMax']}\n            allowDecimals={false}\n          />\n          <YAxis yAxisId=\"wpm\"/>\n          <YAxis yAxisId=\"errors\" orientation=\"right\" allowDecimals={false}/>\n          <Tooltip/>\n        </ComposedChart>\n      </div>\n      <div className=\"raw\">\n        <h3>raw</h3>\n        <h2>{Math.round(rawWpm(state))}</h2>\n      </div>\n      <div className=\"chars\">\n        <h3>characters</h3>\n        <h2>{counts.correct}/{counts.incorrect}/{counts.extra}/{counts.missing}</h2>\n      </div>\n      <div className=\"time\">\n        <h3>time</h3>\n        <h2>{Math.round(duration)}s</h2>\n      </div>\n    </div>\n  )\n}\n\nexport default Stats;\n\nfunction charCounts(text: string, typed: string) {\n  let correct = 0, incorrect = 0, missing = 0, extras = 0\n  zip(\n    getWords(text),\n    getWords(typed)\n  ).forEach(([wtext, wtyped]) => {\n    zip(\n      getChars(wtext),\n      getChars(wtyped)\n    ).forEach(([chtext, chtyped]) => {\n      if (!chtext) extras++;\n      if (!chtyped) missing++;\n      else if (chtext === chtyped) correct++;\n      else incorrect++;\n    });\n    correct++; // spaces\n  });\n  correct--; // does not end with space\n  return {correct, incorrect, missing, extra: extras }\n}\n\nfunction slicePoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime + (second - 1) * 1000,\n    startTime + (second + 2) * 1000,\n    true\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice)!.typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return Math.round(rawWpm(st));\n}\n\nfunction wpmPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime,\n    startTime + (second + 1) * 1000,\n    true\n  );\n  if (slice.length === 0) return 0;\n  const typed = last(slice)!.typed;\n  const st = { typed, content: state.content, timeline: slice };\n  return Math.round(netWpm(st));\n}\n\nfunction errorPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime + second * 1000,\n    startTime + (second + 1) * 1000,\n    false\n  );\n  if (slice.length === 0) return null;\n  return slice.reduce((errs, item) => {\n    return errs + Number(mistypedLast({\n      typed: item.typed,\n      content: state.content\n    }));\n  }, 0) || null;\n}\n\nfunction typedPoint(state: Typer.State, second: number) {\n  const startTime = state.timeline[0].timestamp;\n  let slice = timeSlice(\n    state, \n    startTime,\n    startTime + (second + 1) * 1000,\n    false\n  );\n  if (slice.length === 0) return '';\n  return last(slice)!.typed;\n}","import React from 'react';\nimport TypingTest from './TypingTest';\nimport Stats from './Stats';\nimport { useTyper } from './Typer';\n\ninterface Props {\n  onKeyPress(e: React.KeyboardEvent<HTMLInputElement>, direction: 'up' | 'down'): boolean;\n}\n\nfunction Screens({ onKeyPress }: Props) {\n  const { screen } = useTyper();\n\n  return screen === 'stats' \n        ? <Stats />\n        : <TypingTest onKeyPress={onKeyPress} />;\n}\n\nexport default Screens;","import React from 'react';\nimport reducer from '../reducers';\nimport Screens from './Screens';\n\nexport * from '../util/handlers';\n\nconst StateContext = \n  React.createContext<Typer.State>(init({ text: '' })!);\nconst DispatchContext = \n  React.createContext<React.Dispatch<Typer.Actions.Any> | null>(null);\n\ninterface Props {\n  typed?: string;\n  content: Typer.Content;\n  restartOnContentChange?: boolean\n  onType?(state: Typer.State): void;\n  onKeyPress?(e: React.KeyboardEvent<HTMLInputElement>, direction: 'up' | 'down'): boolean\n}\n\nexport function Typer({ \n  typed, \n  content, \n  onType,\n  onKeyPress = () => false,\n  restartOnContentChange = true \n}: Props) {\n  const [state, dispatch] = React.useReducer(reducer, null, () => init(content));\n\n  React.useEffect(() => {\n    dispatch({ type: 'init', content, reset: restartOnContentChange });\n  }, [content, restartOnContentChange]);\n\n  React.useEffect(() => {\n    if (!typed) return;\n    dispatch({ type: 'merge', state: { typed }});\n  }, [typed])\n\n  const prevTyped = React.useRef<string | null>(null);\n  React.useEffect(() => {\n    if (!onType || prevTyped.current === state!.typed) return;\n    if (prevTyped.current !== null) onType(state!);\n    prevTyped.current = state!.typed;\n  }, [state, onType]);\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state!}>\n        <Screens onKeyPress={onKeyPress}/>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n\nexport function useTyper() {\n  return React.useContext(StateContext);\n}\n\nexport function useTyperDispatch() {\n  return React.useContext(DispatchContext)!;\n}\n\nfunction init(content: Typer.Content) {\n  return reducer(null, { type: 'init', content, reset: true });\n}"],"sourceRoot":""}